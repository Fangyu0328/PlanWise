{"ast":null,"code":"// openAIservice.js\nimport axios from 'axios';\nconst API_URL = 'http://localhost:4000/api';\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || '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';\nconst API_ENDPOINT = 'https://api.openai.com/v1/chat/completions';\n\n// Default values to use when encountering NaN\nconst DEFAULT_VALUES = {\n  estimatedHours: 1,\n  maxTasksPerDay: 5,\n  breakBetweenTasks: 15,\n  splitTaskThreshold: 2,\n  priorityValue: 2\n};\n\n/**\n * Safely parses a date string or object into a valid Date object\n * @param {string|Date} dateValue - Date string or object to parse\n * @param {Date} fallback - Fallback date to use if parsing fails\n * @returns {Date} - Valid Date object\n */\nconst safeParseDate = (dateValue, fallback = new Date()) => {\n  try {\n    // If it's already a Date object\n    if (dateValue instanceof Date) {\n      return isNaN(dateValue.getTime()) ? fallback : dateValue;\n    }\n\n    // If it's a string\n    if (typeof dateValue === 'string') {\n      const date = new Date(dateValue);\n      return isNaN(date.getTime()) ? fallback : date;\n    }\n\n    // Default fallback\n    return fallback;\n  } catch (e) {\n    console.warn(\"Error parsing date:\", e);\n    return fallback;\n  }\n};\n\n/**\n * Parse natural language input to calendar events with OpenAI\n * @param {string} text - Natural language description of event\n * @returns {Promise<Object>} - Parsed event data\n */\nexport const parseEventText = async text => {\n  try {\n    // Use OpenAI to process the event text\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a calendar event assistant. Extract event information from user input and create a simplified title.\n            \n            Examples:\n            - Input: \"I will have dinner with John tomorrow night at 7pm\"\n              Output: Title should be \"Dinner with John\", date is tomorrow, time is 7pm\n            - Input: \"Cancel my meeting with marketing team\"\n              Output: Action should be cancel, event to cancel is \"meeting with marketing team\"\n            \n            Format your response as a JSON object with these fields:\n            - action: 'add' or 'cancel'\n            - title: Simplified event title (remove date/time info, focus on the core event)\n            - start: Event start time (ISO format)\n            - end: Event end time (ISO format)\n            - location: Optional location (if mentioned)\n            - notes: Optional notes (if any additional information is provided)`\n      }, {\n        role: \"user\",\n        content: text\n      }],\n      temperature: 0.3,\n      max_tokens: 250\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    // Parse the OpenAI response\n    const result = JSON.parse(response.data.choices[0].message.content);\n\n    // Safely convert string dates to Date objects\n    const now = new Date();\n    const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n    return {\n      ...result,\n      start: safeParseDate(result.start, now),\n      end: safeParseDate(result.end, oneHourLater)\n    };\n  } catch (error) {\n    console.error('Error processing event with OpenAI:', error);\n    // Fallback to API or simple parsing if OpenAI call fails\n    try {\n      const response = await axios.post(`${API_URL}/parse-event`, {\n        text\n      });\n      const result = response.data;\n      const now = new Date();\n      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n      return {\n        ...result,\n        start: safeParseDate(result.start, now),\n        end: safeParseDate(result.end, oneHourLater)\n      };\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n\n      // If available, use the local fallback function defined in SmartEventEntry\n      if (typeof window.fallbackParsing === 'function') {\n        return window.fallbackParsing(text);\n      }\n\n      // Return a basic event object as last resort\n      const now = new Date();\n      const later = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour later\n\n      return {\n        action: 'add',\n        title: text,\n        start: now,\n        end: later,\n        location: '',\n        notes: 'Created with basic fallback parsing.'\n      };\n    }\n  }\n};\n\n/**\n * Generate optimized task schedule based on priorities, deadlines, and existing calendar events\n * @param {Array} tasks - List of tasks with priorities and deadlines\n * @param {Array} events - Existing calendar events\n * @param {Object} preferences - User preferences for scheduling\n * @returns {Promise<Array>} - Optimized schedule of tasks\n */\nexport const optimizeTaskSchedule = async (tasks, events, preferences) => {\n  try {\n    var _preferences$workingH, _preferences$workingH2;\n    // Validate input data before proceeding\n    if (!Array.isArray(tasks) || tasks.length === 0) {\n      throw new Error(\"No tasks provided for scheduling\");\n    }\n    if (!preferences || typeof preferences !== 'object') {\n      throw new Error(\"Invalid scheduling preferences\");\n    }\n    console.log(\"Starting optimizeTaskSchedule with:\", {\n      taskCount: tasks.length,\n      eventCount: (events === null || events === void 0 ? void 0 : events.length) || 0,\n      preferences\n    });\n\n    // Prepare task and event data for OpenAI with validation\n    const taskData = tasks.map(task => {\n      // Validate priority\n      let priorityValue = DEFAULT_VALUES.priorityValue;\n      if (task.priority !== undefined) {\n        if (typeof task.priority === 'object' && task.priority !== null) {\n          const parsedPriority = parseInt(task.priority.value, 10);\n          priorityValue = isNaN(parsedPriority) ? DEFAULT_VALUES.priorityValue : parsedPriority;\n        } else if (typeof task.priority === 'number' || typeof task.priority === 'string') {\n          const parsedValue = parseInt(task.priority, 10);\n          priorityValue = isNaN(parsedValue) ? DEFAULT_VALUES.priorityValue : parsedValue;\n        }\n      }\n\n      // Validate duration\n      let duration = DEFAULT_VALUES.estimatedHours;\n      if (task.duration !== undefined) {\n        const parsedDuration = parseFloat(task.duration);\n        duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n      } else if (task.estimatedHours !== undefined) {\n        const parsedDuration = parseFloat(task.estimatedHours);\n        duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n      }\n\n      // Handle deadline safely\n      let deadline;\n      try {\n        if (task.fullDeadline) {\n          deadline = task.fullDeadline;\n        } else if (task.deadline) {\n          const deadlineDate = typeof task.deadline === 'string' ? task.deadline : task.deadline.toISOString().split('T')[0];\n          const deadlineTime = task.deadlineTime || '17:00';\n          deadline = `${deadlineDate}T${deadlineTime}`;\n        } else {\n          // Default deadline: 1 week from now\n          const defaultDeadline = new Date();\n          defaultDeadline.setDate(defaultDeadline.getDate() + 7);\n          deadline = defaultDeadline.toISOString();\n        }\n      } catch (e) {\n        console.warn(\"Error creating deadline for task:\", task.id, e);\n        // Default to 1 week from now\n        const defaultDeadline = new Date();\n        defaultDeadline.setDate(defaultDeadline.getDate() + 7);\n        deadline = defaultDeadline.toISOString();\n      }\n\n      // Validate and extract category\n      let category = 'work';\n      if (task.category) {\n        if (typeof task.category === 'object' && task.category !== null && task.category.id) {\n          category = task.category.id;\n        } else if (typeof task.category === 'string') {\n          category = task.category;\n        }\n      }\n      return {\n        id: task.id,\n        title: task.title || task.name || `Task ${task.id}`,\n        priority: priorityValue,\n        duration: duration,\n        deadline: deadline,\n        category: category\n      };\n    });\n\n    // Include existing calendar events to avoid conflicts\n    const calendarEvents = Array.isArray(events) ? events.map(event => {\n      let startTime, endTime;\n      try {\n        startTime = typeof event.start === 'string' ? event.start : event.start.toISOString();\n      } catch (e) {\n        // Fallback for invalid start time\n        startTime = new Date().toISOString();\n      }\n      try {\n        endTime = typeof event.end === 'string' ? event.end : event.end.toISOString();\n      } catch (e) {\n        // Fallback for invalid end time - set to 1 hour after start\n        const start = new Date(startTime);\n        const end = new Date(start.getTime() + 60 * 60 * 1000);\n        endTime = end.toISOString();\n      }\n      return {\n        title: event.title || 'Untitled Event',\n        start: startTime,\n        end: endTime\n      };\n    }) : [];\n\n    // Validate and normalize preferences\n    const safePreferences = {\n      workingHours: {\n        start: ((_preferences$workingH = preferences.workingHours) === null || _preferences$workingH === void 0 ? void 0 : _preferences$workingH.start) || '09:00',\n        end: ((_preferences$workingH2 = preferences.workingHours) === null || _preferences$workingH2 === void 0 ? void 0 : _preferences$workingH2.end) || '17:00'\n      },\n      maxTasksPerDay: isNaN(parseInt(preferences.maxTasksPerDay, 10)) ? DEFAULT_VALUES.maxTasksPerDay : parseInt(preferences.maxTasksPerDay, 10),\n      breakBetweenTasks: isNaN(parseInt(preferences.breakBetweenTasks, 10)) ? DEFAULT_VALUES.breakBetweenTasks : parseInt(preferences.breakBetweenTasks, 10),\n      splitTaskThreshold: isNaN(parseFloat(preferences.splitTaskThreshold)) ? DEFAULT_VALUES.splitTaskThreshold : parseFloat(preferences.splitTaskThreshold)\n    };\n\n    // Format working hours for better readability in the prompt\n    const workStartFormatted = safePreferences.workingHours.start;\n    const workEndFormatted = safePreferences.workingHours.end;\n    console.log(\"Formatted preferences:\", safePreferences);\n\n    // Prepare the OpenAI prompt with explicit values\n    const promptContent = `You are a task scheduling assistant. Optimize the user's tasks based on priorities, deadlines, and existing calendar events.\n            \nIMPORTANT SCHEDULING RULES:\n1. Tasks must NEVER overlap with each other or with existing calendar events\n2. Higher priority tasks should be scheduled earlier, especially those with imminent deadlines\n3. If a task is longer than ${safePreferences.splitTaskThreshold} hours, break it into multiple parts of exactly ${safePreferences.splitTaskThreshold} hours each (except for the last part which may be shorter)\n4. Schedule ONLY ONE task per time slot - absolutely no overlapping tasks\n5. Strictly honor the user's working hours: Start at ${workStartFormatted} and end at ${workEndFormatted} each day\n6. Include ${safePreferences.breakBetweenTasks}-minute breaks between consecutive tasks\n7. Schedule a maximum of ${safePreferences.maxTasksPerDay} tasks per day, utilizing the full working day\n8. Put highest priority on meeting the deadline for each task\n9. Schedule tasks efficiently to maximize the use of available time within working hours\n10. IMPORTANT: For longer tasks that need to be split (more than ${safePreferences.splitTaskThreshold} hours), create multiple sessions of exactly ${safePreferences.splitTaskThreshold} hours each (e.g., \"Part 1 of 10\", \"Part 2 of 10\", etc.)\n11. Skip weekends by default - only schedule on Monday through Friday\n\nFormat your response as a JSON array of scheduled tasks, with each task having:\n- id: The original task ID\n- title: Task title \n- start: Start time (ISO format)\n- end: End time (ISO format)\n- category: Task category (use the original task's category)\n- notes: For split tasks, include \"Part X of Y\" where X is the current part number and Y is the total number of parts\n\nYour schedule should look similar to this example:\n[\n  {\n    \"id\": \"123\",\n    \"title\": \"SDS542\",\n    \"start\": \"2025-04-30T09:00:00.000Z\",\n    \"end\": \"2025-04-30T11:00:00.000Z\",\n    \"category\": \"study\",\n    \"notes\": \"Part 1 of 10\"\n  },\n  {\n    \"id\": \"123\",\n    \"title\": \"SDS542\",\n    \"start\": \"2025-04-30T11:15:00.000Z\",\n    \"end\": \"2025-04-30T13:15:00.000Z\",\n    \"category\": \"study\",\n    \"notes\": \"Part 2 of 10\"\n  }\n]\n\nEach task must have a specific time slot with no overlaps.`;\n\n    // Log full debug data\n    console.log(\"Full task data being sent to OpenAI:\", JSON.stringify(taskData, null, 2));\n\n    // Make the API request\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: promptContent\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          tasks: taskData,\n          events: calendarEvents,\n          preferences: safePreferences\n        })\n      }],\n      temperature: 0.2,\n      // Lower temperature for more deterministic results\n      max_tokens: 2500\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    console.log(\"OpenAI response received\");\n\n    // Parse and validate the OpenAI response\n    let parsedSchedule;\n    try {\n      const responseContent = response.data.choices[0].message.content;\n      console.log(\"Raw OpenAI response:\", responseContent);\n\n      // Handle potential JSON formatting issues in the response\n      let cleanedContent = responseContent.trim();\n      // Remove markdown code blocks if present\n      if (cleanedContent.startsWith(\"```\") && cleanedContent.endsWith(\"```\")) {\n        cleanedContent = cleanedContent.slice(3, -3).trim();\n      }\n      // Remove \"json\" language marker if present\n      if (cleanedContent.startsWith(\"json\")) {\n        cleanedContent = cleanedContent.slice(4).trim();\n      }\n      parsedSchedule = JSON.parse(cleanedContent);\n      console.log(\"Parsed schedule result:\", parsedSchedule);\n\n      // Validate each task has required fields\n      if (!Array.isArray(parsedSchedule)) {\n        throw new Error(\"Response is not an array\");\n      }\n      const invalidTasks = parsedSchedule.filter(task => !task.id || !task.title || !task.start || !task.end);\n      if (invalidTasks.length > 0) {\n        console.error(\"Invalid tasks in schedule:\", invalidTasks);\n        throw new Error(`Schedule contains ${invalidTasks.length} invalid tasks`);\n      }\n    } catch (error) {\n      console.error(\"Failed to parse OpenAI response:\", error);\n      return fallbackScheduling(tasks, events, safePreferences);\n    }\n\n    // Convert string dates to Date objects and ensure proper formatting\n    return parsedSchedule.map(task => {\n      const originalTask = tasks.find(t => t.id === task.id);\n      let categoryValue;\n\n      // Handle category properly with robust fallbacks\n      if (originalTask && originalTask.category) {\n        categoryValue = originalTask.category;\n      } else if (task.category) {\n        // If task has category but we can't find original, create a category object\n        if (typeof task.category === 'string') {\n          var _tasks$find;\n          // Find a matching category from the original tasks if possible\n          const matchingCategoryFromTasks = (_tasks$find = tasks.find(t => t.category && (typeof t.category === 'object' && t.category.id === task.category || typeof t.category === 'string' && t.category === task.category))) === null || _tasks$find === void 0 ? void 0 : _tasks$find.category;\n          if (matchingCategoryFromTasks) {\n            categoryValue = matchingCategoryFromTasks;\n          } else {\n            // Create a basic category object\n            categoryValue = {\n              id: task.category,\n              name: task.category.charAt(0).toUpperCase() + task.category.slice(1),\n              color: '#4CAF50' // Default color\n            };\n          }\n        } else {\n          // Category is already an object\n          categoryValue = task.category;\n        }\n      } else {\n        // Default category as a last resort\n        categoryValue = {\n          id: 'work',\n          name: 'Work',\n          color: '#4CAF50'\n        };\n      }\n\n      // Use current time as a fallback for invalid start/end times\n      const now = new Date();\n      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n\n      // Ensure valid start and end dates with safe parsing\n      const startTime = safeParseDate(task.start, now);\n      const endTime = safeParseDate(task.end, oneHourLater);\n      return {\n        ...task,\n        start: startTime,\n        end: endTime,\n        category: categoryValue\n      };\n    });\n  } catch (error) {\n    console.error('Error optimizing task schedule with OpenAI:', error);\n\n    // Try the backend API\n    try {\n      console.log(\"Trying backend API for task scheduling\");\n      const response = await axios.post(`${API_URL}/schedule-tasks`, {\n        tasks,\n        events,\n        preferences\n      });\n\n      // Convert string dates to Date objects in the schedule safely\n      const now = new Date();\n      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n      return response.data.schedule.map(task => ({\n        ...task,\n        start: safeParseDate(task.start, now),\n        end: safeParseDate(task.end, oneHourLater)\n      }));\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      console.log(\"Using local fallback scheduling algorithm\");\n\n      // Fallback to basic scheduling algorithm\n      return fallbackScheduling(tasks, events, preferences);\n    }\n  }\n};\n\n/**\n * Find best meeting times based on participants' availability\n * @param {Array} participantAvailability - Availability data from all participants\n * @param {Object} meetingParams - Meeting parameters (duration, preferred days, etc.)\n * @returns {Promise<Array>} - Best meeting time slots\n */\nexport const findBestMeetingSlots = async (participantAvailability, meetingParams) => {\n  try {\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a meeting scheduling assistant. Find the best meeting times based on all participants' availability.\n            \n            Important considerations:\n            1. Prioritize slots where all participants are available\n            2. If no slot has 100% availability, find slots with maximum participation\n            3. Respect preferred days specified in the meeting parameters\n            4. Ensure the slot duration accommodates the required meeting length\n            5. Stay within the specified time range\n            \n            Format your response as a JSON array of available slots, each containing:\n            - day: Day of the week (e.g., 'monday')\n            - date: Formatted date (e.g., 'May 1')\n            - time: Time range (e.g., '10:00 AM - 11:00 AM')\n            - availability: 'all' or 'partial'\n            - availableCount: Number of available participants (if partial)\n            - totalCount: Total number of participants\n            \n            Sort the slots by best fit (all available first, then by number of available participants).`\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          participantAvailability: participantAvailability,\n          meetingParams: meetingParams\n        })\n      }],\n      temperature: 0.3,\n      max_tokens: 500\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    return JSON.parse(response.data.choices[0].message.content);\n  } catch (error) {\n    console.error('Error finding best meeting slots with OpenAI:', error);\n\n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/find-meeting-slots`, {\n        participantAvailability,\n        meetingParams\n      });\n      return response.data.slots;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackMeetingSlots(participantAvailability, meetingParams);\n    }\n  }\n};\n\n/**\n * Generate personalized habit recommendations based on mood and activity history\n * @param {Array} moodEntries - History of mood entries\n * @param {Array} activityEntries - History of activities\n * @returns {Promise<Array>} - Personalized recommendations\n */\nexport const generateRecommendations = async (moodEntries, activityEntries) => {\n  try {\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a personalized habit recommendation assistant. Analyze the user's mood patterns and activities to suggest an ideal daily schedule.\n            \n            Consider:\n            1. Time-specific mood patterns (morning, afternoon, evening)\n            2. Activities that correlate with positive moods\n            3. Balance across different activity categories\n            4. Sustainable habit formation principles\n            \n            Format your response as a JSON array of recommendation blocks, each with:\n            - id: Unique identifier for the recommendation\n            - title: Section title (e.g., 'Morning Routine', 'Productivity Boost')\n            - activities: Array of suggested activities with:\n              - time: Suggested time (e.g., '07:00 AM')\n              - description: Activity description\n              - category: Category ID (e.g., 'selfCare', 'work', 'exercise')\n              \n            The recommendations should be detailed yet realistic for daily implementation.`\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          moodEntries: moodEntries,\n          activityEntries: activityEntries\n        })\n      }],\n      temperature: 0.5,\n      max_tokens: 1000\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    return JSON.parse(response.data.choices[0].message.content);\n  } catch (error) {\n    console.error('Error generating recommendations with OpenAI:', error);\n\n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/generate-recommendations`, {\n        moodEntries,\n        activityEntries\n      });\n      return response.data.recommendations;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackRecommendations(moodEntries, activityEntries);\n    }\n  }\n};\n\n/**\n * Analyze evening reflection and provide feedback\n * @param {string} reflectionText - User's evening reflection\n * @param {Array} moodEntries - Recent mood entries\n * @param {Array} activityEntries - Recent activity entries\n * @returns {Promise<string>} - Personalized feedback\n */\nexport const analyzeReflection = async (reflectionText, moodEntries, activityEntries) => {\n  try {\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a reflection analysis assistant. Provide insightful feedback on the user's evening reflection, considering their mood and activity patterns.\n            \n            Your feedback should:\n            1. Acknowledge positive behaviors and attitudes\n            2. Identify potential improvement areas tactfully\n            3. Offer specific suggestions aligned with their goals\n            4. Recommend potential habit adjustments based on patterns\n            5. Maintain a warm, encouraging tone\n            \n            Format your response as a thoughtful paragraph of feedback, keeping it concise yet meaningful.`\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          reflection: reflectionText,\n          recentMoods: (moodEntries === null || moodEntries === void 0 ? void 0 : moodEntries.slice(0, 5)) || [],\n          recentActivities: (activityEntries === null || activityEntries === void 0 ? void 0 : activityEntries.slice(0, 10)) || []\n        })\n      }],\n      temperature: 0.7,\n      max_tokens: 500\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    return response.data.choices[0].message.content;\n  } catch (error) {\n    console.error('Error analyzing reflection with OpenAI:', error);\n\n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/analyze-reflection`, {\n        reflectionText,\n        moodEntries,\n        activityEntries\n      });\n      return response.data.feedback;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackReflectionAnalysis(reflectionText);\n    }\n  }\n};\n\n// Fallback scheduling function when APIs fail\nconst fallbackScheduling = (tasks, events, preferences) => {\n  var _preferences$workingH3, _preferences$workingH4;\n  console.log(\"Using fallback scheduling function\");\n\n  // Ensure tasks is an array\n  if (!Array.isArray(tasks) || tasks.length === 0) {\n    console.warn(\"No tasks provided for fallback scheduling\");\n    return [];\n  }\n\n  // Validate preferences\n  const safePreferences = {\n    workingHours: {\n      start: (preferences === null || preferences === void 0 ? void 0 : (_preferences$workingH3 = preferences.workingHours) === null || _preferences$workingH3 === void 0 ? void 0 : _preferences$workingH3.start) || '09:00',\n      end: (preferences === null || preferences === void 0 ? void 0 : (_preferences$workingH4 = preferences.workingHours) === null || _preferences$workingH4 === void 0 ? void 0 : _preferences$workingH4.end) || '17:00'\n    },\n    maxTasksPerDay: isNaN(parseInt(preferences === null || preferences === void 0 ? void 0 : preferences.maxTasksPerDay, 10)) ? DEFAULT_VALUES.maxTasksPerDay : parseInt(preferences === null || preferences === void 0 ? void 0 : preferences.maxTasksPerDay, 10),\n    breakBetweenTasks: isNaN(parseInt(preferences === null || preferences === void 0 ? void 0 : preferences.breakBetweenTasks, 10)) ? DEFAULT_VALUES.breakBetweenTasks : parseInt(preferences === null || preferences === void 0 ? void 0 : preferences.breakBetweenTasks, 10),\n    splitTaskThreshold: isNaN(parseFloat(preferences === null || preferences === void 0 ? void 0 : preferences.splitTaskThreshold)) ? DEFAULT_VALUES.splitTaskThreshold : parseFloat(preferences === null || preferences === void 0 ? void 0 : preferences.splitTaskThreshold)\n  };\n\n  // Sort tasks by priority (high to low) and deadline\n  const sortedTasks = [...tasks].sort((a, b) => {\n    // First get priority values safely\n    const getPriorityValue = task => {\n      if (task.priority !== undefined) {\n        if (typeof task.priority === 'object' && task.priority !== null) {\n          const value = parseInt(task.priority.value, 10);\n          return isNaN(value) ? DEFAULT_VALUES.priorityValue : value;\n        } else if (typeof task.priority === 'number' || typeof task.priority === 'string') {\n          const value = parseInt(task.priority, 10);\n          return isNaN(value) ? DEFAULT_VALUES.priorityValue : value;\n        }\n      }\n      return DEFAULT_VALUES.priorityValue;\n    };\n    const priorityA = getPriorityValue(a);\n    const priorityB = getPriorityValue(b);\n\n    // First by priority (high to low)\n    if (priorityB !== priorityA) {\n      return priorityB - priorityA;\n    }\n\n    // Then by deadline (earlier first) if we can parse them\n    try {\n      // Use safe date parsing\n      const deadlineA = safeParseDate(a.deadline, new Date());\n      const deadlineB = safeParseDate(b.deadline, new Date());\n      return deadlineA - deadlineB;\n    } catch (e) {\n      return 0; // If we can't compare deadlines, consider them equal\n    }\n  });\n  const scheduledTasks = [];\n  const today = new Date();\n\n  // Parse working hours\n  const parseTimeString = timeStr => {\n    try {\n      const parts = timeStr.split(':');\n      return {\n        hours: parseInt(parts[0], 10) || 0,\n        minutes: parseInt(parts[1], 10) || 0\n      };\n    } catch (e) {\n      console.warn(\"Could not parse time string:\", timeStr);\n      return {\n        hours: 0,\n        minutes: 0\n      };\n    }\n  };\n  const workStart = parseTimeString(safePreferences.workingHours.start);\n  const workEnd = parseTimeString(safePreferences.workingHours.end);\n\n  // Calculate break time in milliseconds\n  const breakTimeMs = safePreferences.breakBetweenTasks * 60 * 1000;\n\n  // Start scheduling from today\n  let currentDay = new Date(today);\n  let tasksForToday = 0;\n\n  // Set current time to working hours start\n  currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n\n  // Skip to next weekday if current day is weekend\n  const skipToNextWeekday = date => {\n    const day = date.getDay();\n    if (day === 0) {\n      // Sunday\n      date.setDate(date.getDate() + 1);\n    } else if (day === 6) {\n      // Saturday\n      date.setDate(date.getDate() + 2);\n    }\n    return date;\n  };\n\n  // Make sure we start on a weekday\n  currentDay = skipToNextWeekday(currentDay);\n  for (const task of sortedTasks) {\n    // Get task duration in milliseconds - with validation\n    let duration = DEFAULT_VALUES.estimatedHours;\n    if (task.duration !== undefined) {\n      const parsedDuration = parseFloat(task.duration);\n      duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n    } else if (task.estimatedHours !== undefined) {\n      const parsedDuration = parseFloat(task.estimatedHours);\n      duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n    }\n    const taskDurationMs = duration * 60 * 60 * 1000;\n    const splitThresholdMs = safePreferences.splitTaskThreshold * 60 * 60 * 1000;\n\n    // Get category with validation\n    let categoryValue;\n    if (task.category) {\n      if (typeof task.category === 'object' && task.category !== null) {\n        categoryValue = task.category;\n      } else if (typeof task.category === 'string') {\n        categoryValue = {\n          id: task.category,\n          name: task.category.charAt(0).toUpperCase() + task.category.slice(1),\n          color: '#4CAF50'\n        };\n      }\n    } else {\n      categoryValue = {\n        id: 'work',\n        name: 'Work',\n        color: '#4CAF50'\n      };\n    }\n\n    // Check if task should be split\n    if (taskDurationMs > splitThresholdMs) {\n      // Calculate how many parts to split into\n      const parts = Math.ceil(taskDurationMs / splitThresholdMs);\n      const partDurationMs = splitThresholdMs; // Always use exactly the threshold time for parts\n\n      for (let i = 0; i < parts; i++) {\n        // Check if we've reached max tasks for today\n        if (tasksForToday >= safePreferences.maxTasksPerDay) {\n          // Move to next day\n          currentDay.setDate(currentDay.getDate() + 1);\n          currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n\n          // Skip weekends\n          currentDay = skipToNextWeekday(currentDay);\n          tasksForToday = 0;\n        }\n\n        // Set end time\n        const startTime = new Date(currentDay);\n        let endTime;\n\n        // For the last part, use remaining duration instead of the fixed partDuration\n        if (i === parts - 1) {\n          const remainingDurationMs = taskDurationMs - i * partDurationMs;\n          endTime = new Date(startTime.getTime() + remainingDurationMs);\n        } else {\n          endTime = new Date(startTime.getTime() + partDurationMs);\n        }\n\n        // Check if end time exceeds working hours\n        const workingDayEnd = new Date(currentDay);\n        workingDayEnd.setHours(workEnd.hours, workEnd.minutes, 0, 0);\n        if (endTime > workingDayEnd) {\n          // Move to next day\n          currentDay.setDate(currentDay.getDate() + 1);\n          currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n\n          // Skip weekends\n          currentDay = skipToNextWeekday(currentDay);\n          tasksForToday = 0;\n\n          // Recalculate start and end time\n          const startTime = new Date(currentDay);\n\n          // For the last part, use remaining duration instead of the fixed partDuration\n          if (i === parts - 1) {\n            const remainingDurationMs = taskDurationMs - i * partDurationMs;\n            endTime = new Date(startTime.getTime() + remainingDurationMs);\n          } else {\n            endTime = new Date(startTime.getTime() + partDurationMs);\n          }\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title || task.name}`,\n            start: startTime,\n            end: endTime,\n            category: categoryValue,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        } else {\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title || task.name}`,\n            start: startTime,\n            end: endTime,\n            category: categoryValue,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        }\n\n        // Increase task count and move time forward (including break)\n        tasksForToday++;\n        currentDay = new Date(endTime.getTime() + breakTimeMs);\n      }\n    } else {\n      // Handle regular tasks\n      if (tasksForToday >= safePreferences.maxTasksPerDay) {\n        // Move to next day\n        currentDay.setDate(currentDay.getDate() + 1);\n        currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n\n        // Skip weekends\n        currentDay = skipToNextWeekday(currentDay);\n        tasksForToday = 0;\n      }\n\n      // Set end time\n      const startTime = new Date(currentDay);\n      const endTime = new Date(startTime.getTime() + taskDurationMs);\n\n      // Check if end time exceeds working hours\n      const workingDayEnd = new Date(currentDay);\n      workingDayEnd.setHours(workEnd.hours, workEnd.minutes, 0, 0);\n      if (endTime > workingDayEnd) {\n        // Move to next day\n        currentDay.setDate(currentDay.getDate() + 1);\n        currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n\n        // Skip weekends\n        currentDay = skipToNextWeekday(currentDay);\n        tasksForToday = 0;\n\n        // Recalculate start and end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + taskDurationMs);\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title || task.name,\n          start: startTime,\n          end: endTime,\n          category: categoryValue\n        });\n      } else {\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title || task.name,\n          start: startTime,\n          end: endTime,\n          category: categoryValue\n        });\n      }\n\n      // Increase task count and move time forward (including break)\n      tasksForToday++;\n      currentDay = new Date(endTime.getTime() + breakTimeMs);\n    }\n  }\n  return scheduledTasks;\n};\n\n// Fallback functions for meeting slots, recommendations, etc.\nconst fallbackMeetingSlots = (participantAvailability, meetingParams) => {\n  // Generate three dummy time slots\n  const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];\n\n  // Get preferred days or default to all weekdays\n  const preferredDays = meetingParams !== null && meetingParams !== void 0 && meetingParams.preferredDays && meetingParams.preferredDays.length > 0 ? meetingParams.preferredDays : days;\n\n  // Create dummy slots\n  return [{\n    day: preferredDays[0] || 'monday',\n    date: 'May 1',\n    time: '10:00 AM - 11:00 AM',\n    availability: 'all'\n  }, {\n    day: preferredDays[preferredDays.length > 1 ? 1 : 0] || 'wednesday',\n    date: 'May 3',\n    time: '2:00 PM - 3:00 PM',\n    availability: 'all'\n  }, {\n    day: preferredDays[0] || 'monday',\n    date: 'May 8',\n    time: '11:00 AM - 12:00 PM',\n    availability: 'partial',\n    availableCount: 2,\n    totalCount: 3\n  }];\n};\nconst fallbackRecommendations = (moodEntries, activityEntries) => {\n  // Simple recommendations\n  return [{\n    id: 'morning',\n    title: 'Morning Routine',\n    activities: [{\n      time: '07:00 AM',\n      description: 'Wake up & hydrate',\n      category: 'selfCare'\n    }, {\n      time: '07:15 AM',\n      description: 'Quick stretch or meditation',\n      category: 'selfCare'\n    }, {\n      time: '07:45 AM',\n      description: 'Healthy breakfast',\n      category: 'selfCare'\n    }, {\n      time: '08:15 AM',\n      description: 'Plan your day',\n      category: 'work'\n    }]\n  }, {\n    id: 'balance',\n    title: 'Balance Your Day',\n    activities: [{\n      time: '11:30 AM',\n      description: 'Take a short break',\n      category: 'selfCare'\n    }, {\n      time: '05:00 PM',\n      description: 'Transition from work to personal time',\n      category: 'selfCare'\n    }, {\n      time: '07:00 PM',\n      description: 'Dinner & relaxation',\n      category: 'leisure'\n    }, {\n      time: '10:00 PM',\n      description: 'Wind down routine',\n      category: 'sleep'\n    }]\n  }];\n};\nconst fallbackReflectionAnalysis = reflectionText => {\n  return \"Thank you for sharing your reflection. It's great that you're taking time to review your day. Consider how your activities might be affecting your mood, and remember that small adjustments can lead to significant improvements in your well-being. Keep up the good work with your self-reflection practice!\";\n};\n\n// Create a named export object\nconst openAIService = {\n  parseEventText,\n  optimizeTaskSchedule,\n  findBestMeetingSlots,\n  generateRecommendations,\n  analyzeReflection\n};\nexport default openAIService;","map":{"version":3,"names":["axios","API_URL","OPENAI_API_KEY","process","env","REACT_APP_OPENAI_API_KEY","API_ENDPOINT","DEFAULT_VALUES","estimatedHours","maxTasksPerDay","breakBetweenTasks","splitTaskThreshold","priorityValue","safeParseDate","dateValue","fallback","Date","isNaN","getTime","date","e","console","warn","parseEventText","text","response","post","model","messages","role","content","temperature","max_tokens","headers","result","JSON","parse","data","choices","message","now","oneHourLater","start","end","error","backendError","window","fallbackParsing","later","action","title","location","notes","optimizeTaskSchedule","tasks","events","preferences","_preferences$workingH","_preferences$workingH2","Array","isArray","length","Error","log","taskCount","eventCount","taskData","map","task","priority","undefined","parsedPriority","parseInt","value","parsedValue","duration","parsedDuration","parseFloat","deadline","fullDeadline","deadlineDate","toISOString","split","deadlineTime","defaultDeadline","setDate","getDate","id","category","name","calendarEvents","event","startTime","endTime","safePreferences","workingHours","workStartFormatted","workEndFormatted","promptContent","stringify","parsedSchedule","responseContent","cleanedContent","trim","startsWith","endsWith","slice","invalidTasks","filter","fallbackScheduling","originalTask","find","t","categoryValue","_tasks$find","matchingCategoryFromTasks","charAt","toUpperCase","color","schedule","findBestMeetingSlots","participantAvailability","meetingParams","slots","fallbackMeetingSlots","generateRecommendations","moodEntries","activityEntries","recommendations","fallbackRecommendations","analyzeReflection","reflectionText","reflection","recentMoods","recentActivities","feedback","fallbackReflectionAnalysis","_preferences$workingH3","_preferences$workingH4","sortedTasks","sort","a","b","getPriorityValue","priorityA","priorityB","deadlineA","deadlineB","scheduledTasks","today","parseTimeString","timeStr","parts","hours","minutes","workStart","workEnd","breakTimeMs","currentDay","tasksForToday","setHours","skipToNextWeekday","day","getDay","taskDurationMs","splitThresholdMs","Math","ceil","partDurationMs","i","remainingDurationMs","workingDayEnd","push","days","preferredDays","time","availability","availableCount","totalCount","activities","description","openAIService"],"sources":["/Users/wenxinmiao/Desktop/PlanWise/client/src/Services/openAIservice.js"],"sourcesContent":["// openAIservice.js\nimport axios from 'axios';\n\nconst API_URL = 'http://localhost:4000/api';\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || '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';\nconst API_ENDPOINT = 'https://api.openai.com/v1/chat/completions';\n\n\n// Default values to use when encountering NaN\nconst DEFAULT_VALUES = {\n  estimatedHours: 1,\n  maxTasksPerDay: 5,\n  breakBetweenTasks: 15,\n  splitTaskThreshold: 2,\n  priorityValue: 2\n};\n\n/**\n * Safely parses a date string or object into a valid Date object\n * @param {string|Date} dateValue - Date string or object to parse\n * @param {Date} fallback - Fallback date to use if parsing fails\n * @returns {Date} - Valid Date object\n */\nconst safeParseDate = (dateValue, fallback = new Date()) => {\n  try {\n    // If it's already a Date object\n    if (dateValue instanceof Date) {\n      return isNaN(dateValue.getTime()) ? fallback : dateValue;\n    }\n    \n    // If it's a string\n    if (typeof dateValue === 'string') {\n      const date = new Date(dateValue);\n      return isNaN(date.getTime()) ? fallback : date;\n    }\n    \n    // Default fallback\n    return fallback;\n  } catch (e) {\n    console.warn(\"Error parsing date:\", e);\n    return fallback;\n  }\n};\n\n/**\n * Parse natural language input to calendar events with OpenAI\n * @param {string} text - Natural language description of event\n * @returns {Promise<Object>} - Parsed event data\n */\nexport const parseEventText = async (text) => {\n  try {\n    // Use OpenAI to process the event text\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a calendar event assistant. Extract event information from user input and create a simplified title.\n            \n            Examples:\n            - Input: \"I will have dinner with John tomorrow night at 7pm\"\n              Output: Title should be \"Dinner with John\", date is tomorrow, time is 7pm\n            - Input: \"Cancel my meeting with marketing team\"\n              Output: Action should be cancel, event to cancel is \"meeting with marketing team\"\n            \n            Format your response as a JSON object with these fields:\n            - action: 'add' or 'cancel'\n            - title: Simplified event title (remove date/time info, focus on the core event)\n            - start: Event start time (ISO format)\n            - end: Event end time (ISO format)\n            - location: Optional location (if mentioned)\n            - notes: Optional notes (if any additional information is provided)`\n          },\n          {\n            role: \"user\",\n            content: text\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 250\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    // Parse the OpenAI response\n    const result = JSON.parse(response.data.choices[0].message.content);\n    \n    // Safely convert string dates to Date objects\n    const now = new Date();\n    const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n    \n    return {\n      ...result,\n      start: safeParseDate(result.start, now),\n      end: safeParseDate(result.end, oneHourLater)\n    };\n  } catch (error) {\n    console.error('Error processing event with OpenAI:', error);\n    // Fallback to API or simple parsing if OpenAI call fails\n    try {\n      const response = await axios.post(`${API_URL}/parse-event`, { text });\n      const result = response.data;\n      \n      const now = new Date();\n      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n      \n      return {\n        ...result,\n        start: safeParseDate(result.start, now),\n        end: safeParseDate(result.end, oneHourLater)\n      };\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      \n      // If available, use the local fallback function defined in SmartEventEntry\n      if (typeof window.fallbackParsing === 'function') {\n        return window.fallbackParsing(text);\n      }\n      \n      // Return a basic event object as last resort\n      const now = new Date();\n      const later = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour later\n      \n      return {\n        action: 'add',\n        title: text,\n        start: now,\n        end: later,\n        location: '',\n        notes: 'Created with basic fallback parsing.'\n      };\n    }\n  }\n};\n\n/**\n * Generate optimized task schedule based on priorities, deadlines, and existing calendar events\n * @param {Array} tasks - List of tasks with priorities and deadlines\n * @param {Array} events - Existing calendar events\n * @param {Object} preferences - User preferences for scheduling\n * @returns {Promise<Array>} - Optimized schedule of tasks\n */\nexport const optimizeTaskSchedule = async (tasks, events, preferences) => {\n  try {\n    // Validate input data before proceeding\n    if (!Array.isArray(tasks) || tasks.length === 0) {\n      throw new Error(\"No tasks provided for scheduling\");\n    }\n    \n    if (!preferences || typeof preferences !== 'object') {\n      throw new Error(\"Invalid scheduling preferences\");\n    }\n    \n    console.log(\"Starting optimizeTaskSchedule with:\", { \n      taskCount: tasks.length, \n      eventCount: events?.length || 0, \n      preferences \n    });\n    \n    // Prepare task and event data for OpenAI with validation\n    const taskData = tasks.map(task => {\n      // Validate priority\n      let priorityValue = DEFAULT_VALUES.priorityValue;\n      if (task.priority !== undefined) {\n        if (typeof task.priority === 'object' && task.priority !== null) {\n          const parsedPriority = parseInt(task.priority.value, 10);\n          priorityValue = isNaN(parsedPriority) ? DEFAULT_VALUES.priorityValue : parsedPriority;\n        } else if (typeof task.priority === 'number' || typeof task.priority === 'string') {\n          const parsedValue = parseInt(task.priority, 10);\n          priorityValue = isNaN(parsedValue) ? DEFAULT_VALUES.priorityValue : parsedValue;\n        }\n      }\n      \n      // Validate duration\n      let duration = DEFAULT_VALUES.estimatedHours;\n      if (task.duration !== undefined) {\n        const parsedDuration = parseFloat(task.duration);\n        duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n      } else if (task.estimatedHours !== undefined) {\n        const parsedDuration = parseFloat(task.estimatedHours);\n        duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n      }\n      \n      // Handle deadline safely\n      let deadline;\n      try {\n        if (task.fullDeadline) {\n          deadline = task.fullDeadline; \n        } else if (task.deadline) {\n          const deadlineDate = typeof task.deadline === 'string' ? task.deadline : task.deadline.toISOString().split('T')[0];\n          const deadlineTime = task.deadlineTime || '17:00';\n          deadline = `${deadlineDate}T${deadlineTime}`;\n        } else {\n          // Default deadline: 1 week from now\n          const defaultDeadline = new Date();\n          defaultDeadline.setDate(defaultDeadline.getDate() + 7);\n          deadline = defaultDeadline.toISOString();\n        }\n      } catch (e) {\n        console.warn(\"Error creating deadline for task:\", task.id, e);\n        // Default to 1 week from now\n        const defaultDeadline = new Date();\n        defaultDeadline.setDate(defaultDeadline.getDate() + 7);\n        deadline = defaultDeadline.toISOString();\n      }\n      \n      // Validate and extract category\n      let category = 'work';\n      if (task.category) {\n        if (typeof task.category === 'object' && task.category !== null && task.category.id) {\n          category = task.category.id;\n        } else if (typeof task.category === 'string') {\n          category = task.category;\n        }\n      }\n      \n      return {\n        id: task.id,\n        title: task.title || task.name || `Task ${task.id}`,\n        priority: priorityValue,\n        duration: duration,\n        deadline: deadline,\n        category: category\n      };\n    });\n    \n    // Include existing calendar events to avoid conflicts\n    const calendarEvents = Array.isArray(events) ? events.map(event => {\n      let startTime, endTime;\n      \n      try {\n        startTime = typeof event.start === 'string' ? event.start : event.start.toISOString();\n      } catch (e) {\n        // Fallback for invalid start time\n        startTime = new Date().toISOString();\n      }\n      \n      try {\n        endTime = typeof event.end === 'string' ? event.end : event.end.toISOString();\n      } catch (e) {\n        // Fallback for invalid end time - set to 1 hour after start\n        const start = new Date(startTime);\n        const end = new Date(start.getTime() + 60 * 60 * 1000);\n        endTime = end.toISOString();\n      }\n      \n      return {\n        title: event.title || 'Untitled Event',\n        start: startTime,\n        end: endTime\n      };\n    }) : [];\n    \n    // Validate and normalize preferences\n    const safePreferences = {\n      workingHours: {\n        start: preferences.workingHours?.start || '09:00',\n        end: preferences.workingHours?.end || '17:00',\n      },\n      maxTasksPerDay: isNaN(parseInt(preferences.maxTasksPerDay, 10)) \n        ? DEFAULT_VALUES.maxTasksPerDay \n        : parseInt(preferences.maxTasksPerDay, 10),\n      breakBetweenTasks: isNaN(parseInt(preferences.breakBetweenTasks, 10)) \n        ? DEFAULT_VALUES.breakBetweenTasks \n        : parseInt(preferences.breakBetweenTasks, 10),\n      splitTaskThreshold: isNaN(parseFloat(preferences.splitTaskThreshold)) \n        ? DEFAULT_VALUES.splitTaskThreshold \n        : parseFloat(preferences.splitTaskThreshold)\n    };\n    \n    // Format working hours for better readability in the prompt\n    const workStartFormatted = safePreferences.workingHours.start;\n    const workEndFormatted = safePreferences.workingHours.end;\n    \n    console.log(\"Formatted preferences:\", safePreferences);\n    \n    // Prepare the OpenAI prompt with explicit values\n    const promptContent = `You are a task scheduling assistant. Optimize the user's tasks based on priorities, deadlines, and existing calendar events.\n            \nIMPORTANT SCHEDULING RULES:\n1. Tasks must NEVER overlap with each other or with existing calendar events\n2. Higher priority tasks should be scheduled earlier, especially those with imminent deadlines\n3. If a task is longer than ${safePreferences.splitTaskThreshold} hours, break it into multiple parts of exactly ${safePreferences.splitTaskThreshold} hours each (except for the last part which may be shorter)\n4. Schedule ONLY ONE task per time slot - absolutely no overlapping tasks\n5. Strictly honor the user's working hours: Start at ${workStartFormatted} and end at ${workEndFormatted} each day\n6. Include ${safePreferences.breakBetweenTasks}-minute breaks between consecutive tasks\n7. Schedule a maximum of ${safePreferences.maxTasksPerDay} tasks per day, utilizing the full working day\n8. Put highest priority on meeting the deadline for each task\n9. Schedule tasks efficiently to maximize the use of available time within working hours\n10. IMPORTANT: For longer tasks that need to be split (more than ${safePreferences.splitTaskThreshold} hours), create multiple sessions of exactly ${safePreferences.splitTaskThreshold} hours each (e.g., \"Part 1 of 10\", \"Part 2 of 10\", etc.)\n11. Skip weekends by default - only schedule on Monday through Friday\n\nFormat your response as a JSON array of scheduled tasks, with each task having:\n- id: The original task ID\n- title: Task title \n- start: Start time (ISO format)\n- end: End time (ISO format)\n- category: Task category (use the original task's category)\n- notes: For split tasks, include \"Part X of Y\" where X is the current part number and Y is the total number of parts\n\nYour schedule should look similar to this example:\n[\n  {\n    \"id\": \"123\",\n    \"title\": \"SDS542\",\n    \"start\": \"2025-04-30T09:00:00.000Z\",\n    \"end\": \"2025-04-30T11:00:00.000Z\",\n    \"category\": \"study\",\n    \"notes\": \"Part 1 of 10\"\n  },\n  {\n    \"id\": \"123\",\n    \"title\": \"SDS542\",\n    \"start\": \"2025-04-30T11:15:00.000Z\",\n    \"end\": \"2025-04-30T13:15:00.000Z\",\n    \"category\": \"study\",\n    \"notes\": \"Part 2 of 10\"\n  }\n]\n\nEach task must have a specific time slot with no overlaps.`;\n\n    // Log full debug data\n    console.log(\"Full task data being sent to OpenAI:\", JSON.stringify(taskData, null, 2));\n    \n    // Make the API request\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: promptContent\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              tasks: taskData,\n              events: calendarEvents,\n              preferences: safePreferences\n            })\n          }\n        ],\n        temperature: 0.2, // Lower temperature for more deterministic results\n        max_tokens: 2500\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    console.log(\"OpenAI response received\");\n    \n    // Parse and validate the OpenAI response\n    let parsedSchedule;\n    try {\n      const responseContent = response.data.choices[0].message.content;\n      console.log(\"Raw OpenAI response:\", responseContent);\n      \n      // Handle potential JSON formatting issues in the response\n      let cleanedContent = responseContent.trim();\n      // Remove markdown code blocks if present\n      if (cleanedContent.startsWith(\"```\") && cleanedContent.endsWith(\"```\")) {\n        cleanedContent = cleanedContent.slice(3, -3).trim();\n      }\n      // Remove \"json\" language marker if present\n      if (cleanedContent.startsWith(\"json\")) {\n        cleanedContent = cleanedContent.slice(4).trim();\n      }\n      \n      parsedSchedule = JSON.parse(cleanedContent);\n      console.log(\"Parsed schedule result:\", parsedSchedule);\n      \n      // Validate each task has required fields\n      if (!Array.isArray(parsedSchedule)) {\n        throw new Error(\"Response is not an array\");\n      }\n      \n      const invalidTasks = parsedSchedule.filter(task => \n        !task.id || !task.title || !task.start || !task.end\n      );\n      \n      if (invalidTasks.length > 0) {\n        console.error(\"Invalid tasks in schedule:\", invalidTasks);\n        throw new Error(`Schedule contains ${invalidTasks.length} invalid tasks`);\n      }\n    } catch (error) {\n      console.error(\"Failed to parse OpenAI response:\", error);\n      return fallbackScheduling(tasks, events, safePreferences);\n    }\n    \n    // Convert string dates to Date objects and ensure proper formatting\n    return parsedSchedule.map(task => {\n      const originalTask = tasks.find(t => t.id === task.id);\n      let categoryValue;\n      \n      // Handle category properly with robust fallbacks\n      if (originalTask && originalTask.category) {\n        categoryValue = originalTask.category;\n      } else if (task.category) {\n        // If task has category but we can't find original, create a category object\n        if (typeof task.category === 'string') {\n          // Find a matching category from the original tasks if possible\n          const matchingCategoryFromTasks = tasks.find(t => \n            t.category && (\n              (typeof t.category === 'object' && t.category.id === task.category) ||\n              (typeof t.category === 'string' && t.category === task.category)\n            )\n          )?.category;\n          \n          if (matchingCategoryFromTasks) {\n            categoryValue = matchingCategoryFromTasks;\n          } else {\n            // Create a basic category object\n            categoryValue = { \n              id: task.category, \n              name: task.category.charAt(0).toUpperCase() + task.category.slice(1),\n              color: '#4CAF50' // Default color\n            };\n          }\n        } else {\n          // Category is already an object\n          categoryValue = task.category;\n        }\n      } else {\n        // Default category as a last resort\n        categoryValue = { \n          id: 'work', \n          name: 'Work',\n          color: '#4CAF50'\n        };\n      }\n      \n      // Use current time as a fallback for invalid start/end times\n      const now = new Date();\n      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n      \n      // Ensure valid start and end dates with safe parsing\n      const startTime = safeParseDate(task.start, now);\n      const endTime = safeParseDate(task.end, oneHourLater);\n      \n      return {\n        ...task,\n        start: startTime,\n        end: endTime,\n        category: categoryValue\n      };\n    });\n  } catch (error) {\n    console.error('Error optimizing task schedule with OpenAI:', error);\n    \n    // Try the backend API\n    try {\n      console.log(\"Trying backend API for task scheduling\");\n      const response = await axios.post(`${API_URL}/schedule-tasks`, { \n        tasks, \n        events, \n        preferences \n      });\n      \n      // Convert string dates to Date objects in the schedule safely\n      const now = new Date();\n      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);\n      \n      return response.data.schedule.map(task => ({\n        ...task,\n        start: safeParseDate(task.start, now),\n        end: safeParseDate(task.end, oneHourLater)\n      }));\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      console.log(\"Using local fallback scheduling algorithm\");\n      \n      // Fallback to basic scheduling algorithm\n      return fallbackScheduling(tasks, events, preferences);\n    }\n  }\n};\n\n/**\n * Find best meeting times based on participants' availability\n * @param {Array} participantAvailability - Availability data from all participants\n * @param {Object} meetingParams - Meeting parameters (duration, preferred days, etc.)\n * @returns {Promise<Array>} - Best meeting time slots\n */\nexport const findBestMeetingSlots = async (participantAvailability, meetingParams) => {\n  try {\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a meeting scheduling assistant. Find the best meeting times based on all participants' availability.\n            \n            Important considerations:\n            1. Prioritize slots where all participants are available\n            2. If no slot has 100% availability, find slots with maximum participation\n            3. Respect preferred days specified in the meeting parameters\n            4. Ensure the slot duration accommodates the required meeting length\n            5. Stay within the specified time range\n            \n            Format your response as a JSON array of available slots, each containing:\n            - day: Day of the week (e.g., 'monday')\n            - date: Formatted date (e.g., 'May 1')\n            - time: Time range (e.g., '10:00 AM - 11:00 AM')\n            - availability: 'all' or 'partial'\n            - availableCount: Number of available participants (if partial)\n            - totalCount: Total number of participants\n            \n            Sort the slots by best fit (all available first, then by number of available participants).`\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              participantAvailability: participantAvailability,\n              meetingParams: meetingParams\n            })\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 500\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    return JSON.parse(response.data.choices[0].message.content);\n  } catch (error) {\n    console.error('Error finding best meeting slots with OpenAI:', error);\n    \n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/find-meeting-slots`, {\n        participantAvailability,\n        meetingParams\n      });\n      \n      return response.data.slots;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackMeetingSlots(participantAvailability, meetingParams);\n    }\n  }\n};\n\n/**\n * Generate personalized habit recommendations based on mood and activity history\n * @param {Array} moodEntries - History of mood entries\n * @param {Array} activityEntries - History of activities\n * @returns {Promise<Array>} - Personalized recommendations\n */\nexport const generateRecommendations = async (moodEntries, activityEntries) => {\n  try {\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a personalized habit recommendation assistant. Analyze the user's mood patterns and activities to suggest an ideal daily schedule.\n            \n            Consider:\n            1. Time-specific mood patterns (morning, afternoon, evening)\n            2. Activities that correlate with positive moods\n            3. Balance across different activity categories\n            4. Sustainable habit formation principles\n            \n            Format your response as a JSON array of recommendation blocks, each with:\n            - id: Unique identifier for the recommendation\n            - title: Section title (e.g., 'Morning Routine', 'Productivity Boost')\n            - activities: Array of suggested activities with:\n              - time: Suggested time (e.g., '07:00 AM')\n              - description: Activity description\n              - category: Category ID (e.g., 'selfCare', 'work', 'exercise')\n              \n            The recommendations should be detailed yet realistic for daily implementation.`\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              moodEntries: moodEntries,\n              activityEntries: activityEntries\n            })\n          }\n        ],\n        temperature: 0.5,\n        max_tokens: 1000\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    return JSON.parse(response.data.choices[0].message.content);\n  } catch (error) {\n    console.error('Error generating recommendations with OpenAI:', error);\n    \n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/generate-recommendations`, {\n        moodEntries,\n        activityEntries\n      });\n      \n      return response.data.recommendations;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackRecommendations(moodEntries, activityEntries);\n    }\n  }\n};\n\n/**\n * Analyze evening reflection and provide feedback\n * @param {string} reflectionText - User's evening reflection\n * @param {Array} moodEntries - Recent mood entries\n * @param {Array} activityEntries - Recent activity entries\n * @returns {Promise<string>} - Personalized feedback\n */\nexport const analyzeReflection = async (reflectionText, moodEntries, activityEntries) => {\n  try {\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a reflection analysis assistant. Provide insightful feedback on the user's evening reflection, considering their mood and activity patterns.\n            \n            Your feedback should:\n            1. Acknowledge positive behaviors and attitudes\n            2. Identify potential improvement areas tactfully\n            3. Offer specific suggestions aligned with their goals\n            4. Recommend potential habit adjustments based on patterns\n            5. Maintain a warm, encouraging tone\n            \n            Format your response as a thoughtful paragraph of feedback, keeping it concise yet meaningful.`\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              reflection: reflectionText,\n              recentMoods: moodEntries?.slice(0, 5) || [],\n              recentActivities: activityEntries?.slice(0, 10) || []\n            })\n          }\n        ],\n        temperature: 0.7,\n        max_tokens: 500\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    return response.data.choices[0].message.content;\n  } catch (error) {\n    console.error('Error analyzing reflection with OpenAI:', error);\n    \n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/analyze-reflection`, {\n        reflectionText,\n        moodEntries,\n        activityEntries\n      });\n      \n      return response.data.feedback;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackReflectionAnalysis(reflectionText);\n    }\n  }\n};\n\n// Fallback scheduling function when APIs fail\nconst fallbackScheduling = (tasks, events, preferences) => {\n  console.log(\"Using fallback scheduling function\");\n  \n  // Ensure tasks is an array\n  if (!Array.isArray(tasks) || tasks.length === 0) {\n    console.warn(\"No tasks provided for fallback scheduling\");\n    return [];\n  }\n  \n  // Validate preferences\n  const safePreferences = {\n    workingHours: {\n      start: preferences?.workingHours?.start || '09:00',\n      end: preferences?.workingHours?.end || '17:00'\n    },\n    maxTasksPerDay: isNaN(parseInt(preferences?.maxTasksPerDay, 10)) \n      ? DEFAULT_VALUES.maxTasksPerDay \n      : parseInt(preferences?.maxTasksPerDay, 10),\n    breakBetweenTasks: isNaN(parseInt(preferences?.breakBetweenTasks, 10)) \n      ? DEFAULT_VALUES.breakBetweenTasks \n      : parseInt(preferences?.breakBetweenTasks, 10),\n    splitTaskThreshold: isNaN(parseFloat(preferences?.splitTaskThreshold)) \n      ? DEFAULT_VALUES.splitTaskThreshold \n      : parseFloat(preferences?.splitTaskThreshold)\n  };\n  \n  // Sort tasks by priority (high to low) and deadline\n  const sortedTasks = [...tasks].sort((a, b) => {\n    // First get priority values safely\n    const getPriorityValue = (task) => {\n      if (task.priority !== undefined) {\n        if (typeof task.priority === 'object' && task.priority !== null) {\n          const value = parseInt(task.priority.value, 10);\n          return isNaN(value) ? DEFAULT_VALUES.priorityValue : value;\n        } else if (typeof task.priority === 'number' || typeof task.priority === 'string') {\n          const value = parseInt(task.priority, 10);\n          return isNaN(value) ? DEFAULT_VALUES.priorityValue : value;\n        }\n      }\n      return DEFAULT_VALUES.priorityValue;\n    };\n    \n    const priorityA = getPriorityValue(a);\n    const priorityB = getPriorityValue(b);\n    \n    // First by priority (high to low)\n    if (priorityB !== priorityA) {\n      return priorityB - priorityA;\n    }\n    \n    // Then by deadline (earlier first) if we can parse them\n    try {\n      // Use safe date parsing\n      const deadlineA = safeParseDate(a.deadline, new Date());\n      const deadlineB = safeParseDate(b.deadline, new Date());\n      \n      return deadlineA - deadlineB;\n    } catch (e) {\n      return 0; // If we can't compare deadlines, consider them equal\n    }\n  });\n  \n  const scheduledTasks = [];\n  const today = new Date();\n  \n  // Parse working hours\n  const parseTimeString = (timeStr) => {\n    try {\n      const parts = timeStr.split(':');\n      return {\n        hours: parseInt(parts[0], 10) || 0,\n        minutes: parseInt(parts[1], 10) || 0\n      };\n    } catch (e) {\n      console.warn(\"Could not parse time string:\", timeStr);\n      return { hours: 0, minutes: 0 };\n    }\n  };\n  \n  const workStart = parseTimeString(safePreferences.workingHours.start);\n  const workEnd = parseTimeString(safePreferences.workingHours.end);\n  \n  // Calculate break time in milliseconds\n  const breakTimeMs = safePreferences.breakBetweenTasks * 60 * 1000;\n  \n  // Start scheduling from today\n  let currentDay = new Date(today);\n  let tasksForToday = 0;\n  \n  // Set current time to working hours start\n  currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n  \n  // Skip to next weekday if current day is weekend\n  const skipToNextWeekday = (date) => {\n    const day = date.getDay();\n    if (day === 0) { // Sunday\n      date.setDate(date.getDate() + 1);\n    } else if (day === 6) { // Saturday\n      date.setDate(date.getDate() + 2);\n    }\n    return date;\n  };\n  \n  // Make sure we start on a weekday\n  currentDay = skipToNextWeekday(currentDay);\n  \n  for (const task of sortedTasks) {\n    // Get task duration in milliseconds - with validation\n    let duration = DEFAULT_VALUES.estimatedHours;\n    if (task.duration !== undefined) {\n      const parsedDuration = parseFloat(task.duration);\n      duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n    } else if (task.estimatedHours !== undefined) {\n      const parsedDuration = parseFloat(task.estimatedHours);\n      duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n    }\n    \n    const taskDurationMs = duration * 60 * 60 * 1000;\n    const splitThresholdMs = safePreferences.splitTaskThreshold * 60 * 60 * 1000;\n    \n    // Get category with validation\n    let categoryValue;\n    if (task.category) {\n      if (typeof task.category === 'object' && task.category !== null) {\n        categoryValue = task.category;\n      } else if (typeof task.category === 'string') {\n        categoryValue = {\n          id: task.category,\n          name: task.category.charAt(0).toUpperCase() + task.category.slice(1),\n          color: '#4CAF50'\n        };\n      }\n    } else {\n      categoryValue = {\n        id: 'work',\n        name: 'Work',\n        color: '#4CAF50'\n      };\n    }\n    \n    // Check if task should be split\n    if (taskDurationMs > splitThresholdMs) {\n      // Calculate how many parts to split into\n      const parts = Math.ceil(taskDurationMs / splitThresholdMs);\n      const partDurationMs = splitThresholdMs; // Always use exactly the threshold time for parts\n      \n      for (let i = 0; i < parts; i++) {\n        // Check if we've reached max tasks for today\n        if (tasksForToday >= safePreferences.maxTasksPerDay) {\n          // Move to next day\n          currentDay.setDate(currentDay.getDate() + 1);\n          currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n          \n          // Skip weekends\n          currentDay = skipToNextWeekday(currentDay);\n          \n          tasksForToday = 0;\n        }\n        \n        // Set end time\n        const startTime = new Date(currentDay);\n        let endTime;\n        \n        // For the last part, use remaining duration instead of the fixed partDuration\n        if (i === parts - 1) {\n          const remainingDurationMs = taskDurationMs - (i * partDurationMs);\n          endTime = new Date(startTime.getTime() + remainingDurationMs);\n        } else {\n          endTime = new Date(startTime.getTime() + partDurationMs);\n        }\n        \n        // Check if end time exceeds working hours\n        const workingDayEnd = new Date(currentDay);\n        workingDayEnd.setHours(workEnd.hours, workEnd.minutes, 0, 0);\n        \n        if (endTime > workingDayEnd) {\n          // Move to next day\n          currentDay.setDate(currentDay.getDate() + 1);\n          currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n          \n          // Skip weekends\n          currentDay = skipToNextWeekday(currentDay);\n          \n          tasksForToday = 0;\n          \n          // Recalculate start and end time\n          const startTime = new Date(currentDay);\n          \n          // For the last part, use remaining duration instead of the fixed partDuration\n          if (i === parts - 1) {\n            const remainingDurationMs = taskDurationMs - (i * partDurationMs);\n            endTime = new Date(startTime.getTime() + remainingDurationMs);\n          } else {\n            endTime = new Date(startTime.getTime() + partDurationMs);\n          }\n          \n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title || task.name}`,\n            start: startTime,\n            end: endTime,\n            category: categoryValue,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        } else {\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title || task.name}`,\n            start: startTime,\n            end: endTime,\n            category: categoryValue,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        }\n        \n        // Increase task count and move time forward (including break)\n        tasksForToday++;\n        currentDay = new Date(endTime.getTime() + breakTimeMs);\n      }\n    } else {\n      // Handle regular tasks\n      if (tasksForToday >= safePreferences.maxTasksPerDay) {\n        // Move to next day\n        currentDay.setDate(currentDay.getDate() + 1);\n        currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n        \n        // Skip weekends\n        currentDay = skipToNextWeekday(currentDay);\n        \n        tasksForToday = 0;\n      }\n      \n      // Set end time\n      const startTime = new Date(currentDay);\n      const endTime = new Date(startTime.getTime() + taskDurationMs);\n      \n      // Check if end time exceeds working hours\n      const workingDayEnd = new Date(currentDay);\n      workingDayEnd.setHours(workEnd.hours, workEnd.minutes, 0, 0);\n      \n      if (endTime > workingDayEnd) {\n        // Move to next day\n        currentDay.setDate(currentDay.getDate() + 1);\n        currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n        \n        // Skip weekends\n        currentDay = skipToNextWeekday(currentDay);\n        \n        tasksForToday = 0;\n        \n        // Recalculate start and end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + taskDurationMs);\n        \n        scheduledTasks.push({\n          id: task.id,\n          title: task.title || task.name,\n          start: startTime,\n          end: endTime,\n          category: categoryValue\n        });\n      } else {\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title || task.name,\n          start: startTime,\n          end: endTime,\n          category: categoryValue\n        });\n      }\n      \n      // Increase task count and move time forward (including break)\n      tasksForToday++;\n      currentDay = new Date(endTime.getTime() + breakTimeMs);\n    }\n  }\n  \n  return scheduledTasks;\n};\n\n// Fallback functions for meeting slots, recommendations, etc.\nconst fallbackMeetingSlots = (participantAvailability, meetingParams) => {\n  // Generate three dummy time slots\n  const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];\n  \n  // Get preferred days or default to all weekdays\n  const preferredDays = meetingParams?.preferredDays && meetingParams.preferredDays.length > 0 \n    ? meetingParams.preferredDays \n    : days;\n  \n  // Create dummy slots\n  return [\n    {\n      day: preferredDays[0] || 'monday',\n      date: 'May 1',\n      time: '10:00 AM - 11:00 AM',\n      availability: 'all'\n    },\n    {\n      day: preferredDays[preferredDays.length > 1 ? 1 : 0] || 'wednesday',\n      date: 'May 3',\n      time: '2:00 PM - 3:00 PM',\n      availability: 'all'\n    },\n    {\n      day: preferredDays[0] || 'monday',\n      date: 'May 8',\n      time: '11:00 AM - 12:00 PM',\n      availability: 'partial',\n      availableCount: 2,\n      totalCount: 3\n    }\n  ];\n};\n\nconst fallbackRecommendations = (moodEntries, activityEntries) => {\n  // Simple recommendations\n  return [\n    {\n      id: 'morning',\n      title: 'Morning Routine',\n      activities: [\n        { time: '07:00 AM', description: 'Wake up & hydrate', category: 'selfCare' },\n        { time: '07:15 AM', description: 'Quick stretch or meditation', category: 'selfCare' },\n        { time: '07:45 AM', description: 'Healthy breakfast', category: 'selfCare' },\n        { time: '08:15 AM', description: 'Plan your day', category: 'work' },\n      ]\n    },\n    {\n      id: 'balance',\n      title: 'Balance Your Day',\n      activities: [\n        { time: '11:30 AM', description: 'Take a short break', category: 'selfCare' },\n        { time: '05:00 PM', description: 'Transition from work to personal time', category: 'selfCare' },\n        { time: '07:00 PM', description: 'Dinner & relaxation', category: 'leisure' },\n        { time: '10:00 PM', description: 'Wind down routine', category: 'sleep' },\n      ]\n    }\n  ];\n};\n\nconst fallbackReflectionAnalysis = (reflectionText) => {\n  return \"Thank you for sharing your reflection. It's great that you're taking time to review your day. Consider how your activities might be affecting your mood, and remember that small adjustments can lead to significant improvements in your well-being. Keep up the good work with your self-reflection practice!\";\n};\n\n// Create a named export object\nconst openAIService = {\n  parseEventText,\n  optimizeTaskSchedule,\n  findBestMeetingSlots,\n  generateRecommendations,\n  analyzeReflection\n};\n\nexport default openAIService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}