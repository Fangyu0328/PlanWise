{"ast":null,"code":"// openAIservice.js\nimport axios from 'axios';\nconst API_URL = 'http://localhost:4000/api';\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || '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';\nconst API_ENDPOINT = 'https://api.openai.com/v1/chat/completions';\n\n// Default values to use when encountering NaN\nconst DEFAULT_VALUES = {\n  estimatedHours: 1,\n  maxTasksPerDay: 5,\n  breakBetweenTasks: 15,\n  splitTaskThreshold: 2,\n  priorityValue: 2\n};\n\n/**\n * Generate optimized task schedule based on priorities, deadlines, and existing calendar events\n * @param {Array} tasks - List of tasks with priorities and deadlines\n * @param {Array} events - Existing calendar events\n * @param {Object} preferences - User preferences for scheduling\n * @returns {Promise<Array>} - Optimized schedule of tasks\n */\nexport const optimizeTaskSchedule = async (tasks, events, preferences) => {\n  try {\n    var _preferences$workingH, _preferences$workingH2;\n    // Validate input data before proceeding\n    if (!Array.isArray(tasks) || tasks.length === 0) {\n      throw new Error(\"No tasks provided for scheduling\");\n    }\n    if (!preferences || typeof preferences !== 'object') {\n      throw new Error(\"Invalid scheduling preferences\");\n    }\n    console.log(\"Starting optimizeTaskSchedule with:\", {\n      taskCount: tasks.length,\n      eventCount: (events === null || events === void 0 ? void 0 : events.length) || 0,\n      preferences\n    });\n\n    // Prepare task and event data for OpenAI with validation\n    const taskData = tasks.map(task => {\n      // Validate priority\n      let priorityValue = DEFAULT_VALUES.priorityValue;\n      if (task.priority !== undefined) {\n        if (typeof task.priority === 'object' && task.priority !== null) {\n          const parsedValue = parseInt(task.priority.value, 10);\n          priorityValue = isNaN(parsedValue) ? DEFAULT_VALUES.priorityValue : parsedValue;\n        } else if (typeof task.priority === 'number' || typeof task.priority === 'string') {\n          const parsedValue = parseInt(task.priority, 10);\n          priorityValue = isNaN(parsedValue) ? DEFAULT_VALUES.priorityValue : parsedValue;\n        }\n      }\n\n      // Validate duration\n      let duration = DEFAULT_VALUES.estimatedHours;\n      if (task.duration !== undefined) {\n        const parsedDuration = parseFloat(task.duration);\n        duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n      } else if (task.estimatedHours !== undefined) {\n        const parsedDuration = parseFloat(task.estimatedHours);\n        duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n      }\n\n      // Validate and extract category\n      let category = 'work';\n      if (task.category) {\n        if (typeof task.category === 'object' && task.category !== null && task.category.id) {\n          category = task.category.id;\n        } else if (typeof task.category === 'string') {\n          category = task.category;\n        }\n      }\n      return {\n        id: task.id,\n        title: task.title || task.name,\n        priority: priorityValue,\n        duration: duration,\n        deadline: task.deadline,\n        category: category\n      };\n    });\n\n    // Validate and format event data\n    const calendarEvents = Array.isArray(events) ? events.map(event => {\n      let startTime, endTime;\n      try {\n        startTime = typeof event.start === 'string' ? event.start : event.start.toISOString();\n      } catch (e) {\n        // Fallback for invalid start time\n        startTime = new Date().toISOString();\n      }\n      try {\n        endTime = typeof event.end === 'string' ? event.end : event.end.toISOString();\n      } catch (e) {\n        // Fallback for invalid end time - set to 1 hour after start\n        const start = new Date(startTime);\n        const end = new Date(start.getTime() + 60 * 60 * 1000);\n        endTime = end.toISOString();\n      }\n      return {\n        title: event.title || 'Untitled Event',\n        start: startTime,\n        end: endTime\n      };\n    }) : [];\n\n    // Validate and normalize preferences\n    const safePreferences = {\n      workingHours: {\n        start: ((_preferences$workingH = preferences.workingHours) === null || _preferences$workingH === void 0 ? void 0 : _preferences$workingH.start) || '09:00',\n        end: ((_preferences$workingH2 = preferences.workingHours) === null || _preferences$workingH2 === void 0 ? void 0 : _preferences$workingH2.end) || '17:00'\n      },\n      maxTasksPerDay: isNaN(parseInt(preferences.maxTasksPerDay, 10)) ? DEFAULT_VALUES.maxTasksPerDay : parseInt(preferences.maxTasksPerDay, 10),\n      breakBetweenTasks: isNaN(parseInt(preferences.breakBetweenTasks, 10)) ? DEFAULT_VALUES.breakBetweenTasks : parseInt(preferences.breakBetweenTasks, 10),\n      splitTaskThreshold: isNaN(parseFloat(preferences.splitTaskThreshold)) ? DEFAULT_VALUES.splitTaskThreshold : parseFloat(preferences.splitTaskThreshold)\n    };\n\n    // Format working hours for better readability in the prompt\n    const workStartFormatted = safePreferences.workingHours.start;\n    const workEndFormatted = safePreferences.workingHours.end;\n    console.log(\"Formatted preferences:\", safePreferences);\n\n    // Prepare the OpenAI prompt with explicit values\n    const promptContent = `You are a task scheduling assistant. Optimize the user's tasks based on priorities, deadlines, and existing calendar events.\n            \nIMPORTANT SCHEDULING RULES:\n1. Tasks must NEVER overlap with each other or with existing calendar events\n2. Higher priority tasks should be scheduled earlier, especially those with imminent deadlines\n3. If a task is longer than ${safePreferences.splitTaskThreshold} hours, break it into multiple smaller sessions across different time slots or days\n4. Schedule ONLY ONE task per time slot - absolutely no overlapping tasks\n5. Strictly honor the user's working hours: Start at ${workStartFormatted} and end at ${workEndFormatted} each day\n6. Include ${safePreferences.breakBetweenTasks}-minute breaks between consecutive tasks\n7. Schedule a maximum of ${safePreferences.maxTasksPerDay} tasks per day, utilizing the full working day\n8. Put highest priority on meeting the deadline for each task\n9. Schedule tasks efficiently to maximize the use of available time within working hours\n\nFormat your response as a JSON array of scheduled tasks, with each task having:\n- id: The original task ID\n- title: Task title \n- start: Start time (ISO format)\n- end: End time (ISO format)\n- category: Task category (use the original task's category)\n- notes: Optional scheduling notes (e.g., \"Part 1 of 3\" for split tasks)\n\nEach task must have a specific time slot with no overlaps.`;\n\n    // Log full debug data\n    console.log(\"Full task data being sent to OpenAI:\", JSON.stringify(taskData, null, 2));\n\n    // Make the API request\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: promptContent\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          tasks: taskData,\n          events: calendarEvents,\n          preferences: safePreferences\n        })\n      }],\n      temperature: 0.2,\n      // Lower temperature for more deterministic results\n      max_tokens: 1500\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    console.log(\"OpenAI response received\");\n\n    // Parse and validate the OpenAI response\n    let parsedSchedule;\n    try {\n      const responseContent = response.data.choices[0].message.content;\n      console.log(\"Raw OpenAI response:\", responseContent);\n      parsedSchedule = JSON.parse(responseContent);\n      console.log(\"Parsed schedule result:\", parsedSchedule);\n\n      // Validate each task has required fields\n      const validSchedule = Array.isArray(parsedSchedule) && parsedSchedule.every(task => task.id && task.title && task.start && task.end);\n      if (!validSchedule) {\n        throw new Error(\"Invalid schedule format returned\");\n      }\n    } catch (error) {\n      console.error(\"Failed to parse OpenAI response:\", error);\n      return fallbackScheduling(tasks, events, safePreferences);\n    }\n\n    // Convert string dates to Date objects and ensure proper formatting\n    return parsedSchedule.map(task => {\n      const originalTask = tasks.find(t => t.id === task.id);\n      let categoryValue;\n\n      // Handle category properly with robust fallbacks\n      if (originalTask && originalTask.category) {\n        categoryValue = originalTask.category;\n      } else if (task.category) {\n        // If task has category but we can't find original, create a category object\n        if (typeof task.category === 'string') {\n          var _tasks$find;\n          // Find a matching category from the original tasks if possible\n          const matchingCategoryFromTasks = (_tasks$find = tasks.find(t => t.category && (typeof t.category === 'object' && t.category.id === task.category || typeof t.category === 'string' && t.category === task.category))) === null || _tasks$find === void 0 ? void 0 : _tasks$find.category;\n          if (matchingCategoryFromTasks) {\n            categoryValue = matchingCategoryFromTasks;\n          } else {\n            // Create a basic category object\n            categoryValue = {\n              id: task.category,\n              name: task.category.charAt(0).toUpperCase() + task.category.slice(1),\n              color: '#4CAF50' // Default color\n            };\n          }\n        } else {\n          // Category is already an object\n          categoryValue = task.category;\n        }\n      } else {\n        // Default category as a last resort\n        categoryValue = {\n          id: 'work',\n          name: 'Work',\n          color: '#4CAF50'\n        };\n      }\n\n      // Ensure valid start and end dates\n      let startTime, endTime;\n      try {\n        startTime = new Date(task.start);\n        if (isNaN(startTime.getTime())) {\n          throw new Error(\"Invalid start time\");\n        }\n      } catch (e) {\n        console.warn(`Invalid start time for task ${task.id}, using current time:`, e);\n        startTime = new Date();\n      }\n      try {\n        endTime = new Date(task.end);\n        if (isNaN(endTime.getTime())) {\n          throw new Error(\"Invalid end time\");\n        }\n      } catch (e) {\n        console.warn(`Invalid end time for task ${task.id}, using start + 1 hour:`, e);\n        endTime = new Date(startTime.getTime() + 60 * 60 * 1000);\n      }\n      return {\n        ...task,\n        start: startTime,\n        end: endTime,\n        category: categoryValue\n      };\n    });\n  } catch (error) {\n    console.error('Error optimizing task schedule with OpenAI:', error);\n\n    // Try the backend API\n    try {\n      console.log(\"Trying backend API for task scheduling\");\n      const response = await axios.post(`${API_URL}/schedule-tasks`, {\n        tasks,\n        events,\n        preferences\n      });\n\n      // Convert string dates to Date objects in the schedule\n      return response.data.schedule.map(task => ({\n        ...task,\n        start: new Date(task.start),\n        end: new Date(task.end)\n      }));\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      console.log(\"Using local fallback scheduling algorithm\");\n\n      // Fallback to basic scheduling algorithm\n      return fallbackScheduling(tasks, events, preferences);\n    }\n  }\n};\n\n// Fallback scheduling function when APIs fail\nconst fallbackScheduling = (tasks, events, preferences) => {\n  var _preferences$workingH3, _preferences$workingH4;\n  console.log(\"Using fallback scheduling function\");\n\n  // Ensure tasks is an array\n  if (!Array.isArray(tasks) || tasks.length === 0) {\n    console.warn(\"No tasks provided for fallback scheduling\");\n    return [];\n  }\n\n  // Validate preferences\n  const safePreferences = {\n    workingHours: {\n      start: (preferences === null || preferences === void 0 ? void 0 : (_preferences$workingH3 = preferences.workingHours) === null || _preferences$workingH3 === void 0 ? void 0 : _preferences$workingH3.start) || '09:00',\n      end: (preferences === null || preferences === void 0 ? void 0 : (_preferences$workingH4 = preferences.workingHours) === null || _preferences$workingH4 === void 0 ? void 0 : _preferences$workingH4.end) || '17:00'\n    },\n    maxTasksPerDay: isNaN(parseInt(preferences === null || preferences === void 0 ? void 0 : preferences.maxTasksPerDay, 10)) ? DEFAULT_VALUES.maxTasksPerDay : parseInt(preferences === null || preferences === void 0 ? void 0 : preferences.maxTasksPerDay, 10),\n    breakBetweenTasks: isNaN(parseInt(preferences === null || preferences === void 0 ? void 0 : preferences.breakBetweenTasks, 10)) ? DEFAULT_VALUES.breakBetweenTasks : parseInt(preferences === null || preferences === void 0 ? void 0 : preferences.breakBetweenTasks, 10),\n    splitTaskThreshold: isNaN(parseFloat(preferences === null || preferences === void 0 ? void 0 : preferences.splitTaskThreshold)) ? DEFAULT_VALUES.splitTaskThreshold : parseFloat(preferences === null || preferences === void 0 ? void 0 : preferences.splitTaskThreshold)\n  };\n\n  // Sort tasks by priority (high to low) and deadline\n  const sortedTasks = [...tasks].sort((a, b) => {\n    // First get priority values safely\n    const getPriorityValue = task => {\n      if (task.priority !== undefined) {\n        if (typeof task.priority === 'object' && task.priority !== null) {\n          const value = parseInt(task.priority.value, 10);\n          return isNaN(value) ? DEFAULT_VALUES.priorityValue : value;\n        } else if (typeof task.priority === 'number' || typeof task.priority === 'string') {\n          const value = parseInt(task.priority, 10);\n          return isNaN(value) ? DEFAULT_VALUES.priorityValue : value;\n        }\n      }\n      return DEFAULT_VALUES.priorityValue;\n    };\n    const priorityA = getPriorityValue(a);\n    const priorityB = getPriorityValue(b);\n\n    // First by priority (high to low)\n    if (priorityB !== priorityA) {\n      return priorityB - priorityA;\n    }\n\n    // Then by deadline (earlier first) if we can parse them\n    try {\n      return new Date(a.deadline) - new Date(b.deadline);\n    } catch (e) {\n      return 0; // If we can't compare deadlines, consider them equal\n    }\n  });\n  const scheduledTasks = [];\n  const today = new Date();\n\n  // Parse working hours\n  const parseTimeString = timeStr => {\n    try {\n      const parts = timeStr.split(':');\n      return {\n        hours: parseInt(parts[0], 10) || 0,\n        minutes: parseInt(parts[1], 10) || 0\n      };\n    } catch (e) {\n      console.warn(\"Could not parse time string:\", timeStr);\n      return {\n        hours: 0,\n        minutes: 0\n      };\n    }\n  };\n  const workStart = parseTimeString(safePreferences.workingHours.start);\n  const workEnd = parseTimeString(safePreferences.workingHours.end);\n\n  // Calculate break time in milliseconds\n  const breakTimeMs = safePreferences.breakBetweenTasks * 60 * 1000;\n\n  // Start scheduling from today\n  let currentDay = new Date(today);\n  let tasksForToday = 0;\n\n  // Set current time to working hours start\n  currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n  for (const task of sortedTasks) {\n    // Get task duration in milliseconds - with validation\n    let duration = DEFAULT_VALUES.estimatedHours;\n    if (task.duration !== undefined) {\n      const parsedDuration = parseFloat(task.duration);\n      duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n    } else if (task.estimatedHours !== undefined) {\n      const parsedDuration = parseFloat(task.estimatedHours);\n      duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n    }\n    const taskDurationMs = duration * 60 * 60 * 1000;\n    const splitThresholdMs = safePreferences.splitTaskThreshold * 60 * 60 * 1000;\n\n    // Get category with validation\n    let categoryValue;\n    if (task.category) {\n      if (typeof task.category === 'object' && task.category !== null) {\n        categoryValue = task.category;\n      } else if (typeof task.category === 'string') {\n        categoryValue = {\n          id: task.category,\n          name: task.category.charAt(0).toUpperCase() + task.category.slice(1),\n          color: '#4CAF50'\n        };\n      }\n    } else {\n      categoryValue = {\n        id: 'work',\n        name: 'Work',\n        color: '#4CAF50'\n      };\n    }\n\n    // Check if task should be split\n    if (taskDurationMs > splitThresholdMs) {\n      // Calculate how many parts to split into\n      const parts = Math.ceil(taskDurationMs / splitThresholdMs);\n      const partDurationMs = taskDurationMs / parts;\n      for (let i = 0; i < parts; i++) {\n        if (tasksForToday >= safePreferences.maxTasksPerDay) {\n          // Move to next day\n          currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n          currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n          tasksForToday = 0;\n        }\n\n        // Set end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + partDurationMs);\n\n        // Check if end time exceeds working hours\n        const workingDayEnd = new Date(currentDay);\n        workingDayEnd.setHours(workEnd.hours, workEnd.minutes, 0, 0);\n        if (endTime > workingDayEnd) {\n          // Move to next day\n          currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n          currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n          tasksForToday = 0;\n\n          // Recalculate start and end time\n          const startTime = new Date(currentDay);\n          const endTime = new Date(startTime.getTime() + partDurationMs);\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title || task.name} (Part ${i + 1} of ${parts})`,\n            start: startTime,\n            end: endTime,\n            category: categoryValue,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        } else {\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title || task.name} (Part ${i + 1} of ${parts})`,\n            start: startTime,\n            end: endTime,\n            category: categoryValue,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        }\n\n        // Increase task count and move time forward (including break)\n        tasksForToday++;\n        currentDay = new Date(endTime.getTime() + breakTimeMs);\n      }\n    } else {\n      // Handle regular tasks\n      if (tasksForToday >= safePreferences.maxTasksPerDay) {\n        // Move to next day\n        currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n        currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n        tasksForToday = 0;\n      }\n\n      // Set end time\n      const startTime = new Date(currentDay);\n      const endTime = new Date(startTime.getTime() + taskDurationMs);\n\n      // Check if end time exceeds working hours\n      const workingDayEnd = new Date(currentDay);\n      workingDayEnd.setHours(workEnd.hours, workEnd.minutes, 0, 0);\n      if (endTime > workingDayEnd) {\n        // Move to next day\n        currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n        currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n        tasksForToday = 0;\n\n        // Recalculate start and end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + taskDurationMs);\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title || task.name,\n          start: startTime,\n          end: endTime,\n          category: categoryValue\n        });\n      } else {\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title || task.name,\n          start: startTime,\n          end: endTime,\n          category: categoryValue\n        });\n      }\n\n      // Increase task count and move time forward (including break)\n      tasksForToday++;\n      currentDay = new Date(endTime.getTime() + breakTimeMs);\n    }\n  }\n  return scheduledTasks;\n};\n\n// Create a named export object\nconst openAIService = {\n  optimizeTaskSchedule\n};\nexport default openAIService;","map":{"version":3,"names":["axios","API_URL","OPENAI_API_KEY","process","env","REACT_APP_OPENAI_API_KEY","API_ENDPOINT","DEFAULT_VALUES","estimatedHours","maxTasksPerDay","breakBetweenTasks","splitTaskThreshold","priorityValue","optimizeTaskSchedule","tasks","events","preferences","_preferences$workingH","_preferences$workingH2","Array","isArray","length","Error","console","log","taskCount","eventCount","taskData","map","task","priority","undefined","parsedValue","parseInt","value","isNaN","duration","parsedDuration","parseFloat","category","id","title","name","deadline","calendarEvents","event","startTime","endTime","start","toISOString","e","Date","end","getTime","safePreferences","workingHours","workStartFormatted","workEndFormatted","promptContent","JSON","stringify","response","post","model","messages","role","content","temperature","max_tokens","headers","parsedSchedule","responseContent","data","choices","message","parse","validSchedule","every","error","fallbackScheduling","originalTask","find","t","categoryValue","_tasks$find","matchingCategoryFromTasks","charAt","toUpperCase","slice","color","warn","schedule","backendError","_preferences$workingH3","_preferences$workingH4","sortedTasks","sort","a","b","getPriorityValue","priorityA","priorityB","scheduledTasks","today","parseTimeString","timeStr","parts","split","hours","minutes","workStart","workEnd","breakTimeMs","currentDay","tasksForToday","setHours","taskDurationMs","splitThresholdMs","Math","ceil","partDurationMs","i","workingDayEnd","push","notes","openAIService"],"sources":["/Users/wenxinmiao/Desktop/PlanWise/client/src/Services/openAIservice.js"],"sourcesContent":["// openAIservice.js\nimport axios from 'axios';\n\nconst API_URL = 'http://localhost:4000/api';\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || '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';\nconst API_ENDPOINT = 'https://api.openai.com/v1/chat/completions';\n\n// Default values to use when encountering NaN\nconst DEFAULT_VALUES = {\n  estimatedHours: 1,\n  maxTasksPerDay: 5,\n  breakBetweenTasks: 15,\n  splitTaskThreshold: 2,\n  priorityValue: 2\n};\n\n/**\n * Generate optimized task schedule based on priorities, deadlines, and existing calendar events\n * @param {Array} tasks - List of tasks with priorities and deadlines\n * @param {Array} events - Existing calendar events\n * @param {Object} preferences - User preferences for scheduling\n * @returns {Promise<Array>} - Optimized schedule of tasks\n */\nexport const optimizeTaskSchedule = async (tasks, events, preferences) => {\n  try {\n    // Validate input data before proceeding\n    if (!Array.isArray(tasks) || tasks.length === 0) {\n      throw new Error(\"No tasks provided for scheduling\");\n    }\n    \n    if (!preferences || typeof preferences !== 'object') {\n      throw new Error(\"Invalid scheduling preferences\");\n    }\n    \n    console.log(\"Starting optimizeTaskSchedule with:\", { \n      taskCount: tasks.length, \n      eventCount: events?.length || 0, \n      preferences \n    });\n    \n    // Prepare task and event data for OpenAI with validation\n    const taskData = tasks.map(task => {\n      // Validate priority\n      let priorityValue = DEFAULT_VALUES.priorityValue;\n      if (task.priority !== undefined) {\n        if (typeof task.priority === 'object' && task.priority !== null) {\n          const parsedValue = parseInt(task.priority.value, 10);\n          priorityValue = isNaN(parsedValue) ? DEFAULT_VALUES.priorityValue : parsedValue;\n        } else if (typeof task.priority === 'number' || typeof task.priority === 'string') {\n          const parsedValue = parseInt(task.priority, 10);\n          priorityValue = isNaN(parsedValue) ? DEFAULT_VALUES.priorityValue : parsedValue;\n        }\n      }\n      \n      // Validate duration\n      let duration = DEFAULT_VALUES.estimatedHours;\n      if (task.duration !== undefined) {\n        const parsedDuration = parseFloat(task.duration);\n        duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n      } else if (task.estimatedHours !== undefined) {\n        const parsedDuration = parseFloat(task.estimatedHours);\n        duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n      }\n      \n      // Validate and extract category\n      let category = 'work';\n      if (task.category) {\n        if (typeof task.category === 'object' && task.category !== null && task.category.id) {\n          category = task.category.id;\n        } else if (typeof task.category === 'string') {\n          category = task.category;\n        }\n      }\n      \n      return {\n        id: task.id,\n        title: task.title || task.name,\n        priority: priorityValue,\n        duration: duration,\n        deadline: task.deadline,\n        category: category\n      };\n    });\n    \n    // Validate and format event data\n    const calendarEvents = Array.isArray(events) ? events.map(event => {\n      let startTime, endTime;\n      \n      try {\n        startTime = typeof event.start === 'string' ? event.start : event.start.toISOString();\n      } catch (e) {\n        // Fallback for invalid start time\n        startTime = new Date().toISOString();\n      }\n      \n      try {\n        endTime = typeof event.end === 'string' ? event.end : event.end.toISOString();\n      } catch (e) {\n        // Fallback for invalid end time - set to 1 hour after start\n        const start = new Date(startTime);\n        const end = new Date(start.getTime() + 60 * 60 * 1000);\n        endTime = end.toISOString();\n      }\n      \n      return {\n        title: event.title || 'Untitled Event',\n        start: startTime,\n        end: endTime\n      };\n    }) : [];\n    \n    // Validate and normalize preferences\n    const safePreferences = {\n      workingHours: {\n        start: preferences.workingHours?.start || '09:00',\n        end: preferences.workingHours?.end || '17:00',\n      },\n      maxTasksPerDay: isNaN(parseInt(preferences.maxTasksPerDay, 10)) \n        ? DEFAULT_VALUES.maxTasksPerDay \n        : parseInt(preferences.maxTasksPerDay, 10),\n      breakBetweenTasks: isNaN(parseInt(preferences.breakBetweenTasks, 10)) \n        ? DEFAULT_VALUES.breakBetweenTasks \n        : parseInt(preferences.breakBetweenTasks, 10),\n      splitTaskThreshold: isNaN(parseFloat(preferences.splitTaskThreshold)) \n        ? DEFAULT_VALUES.splitTaskThreshold \n        : parseFloat(preferences.splitTaskThreshold)\n    };\n    \n    // Format working hours for better readability in the prompt\n    const workStartFormatted = safePreferences.workingHours.start;\n    const workEndFormatted = safePreferences.workingHours.end;\n    \n    console.log(\"Formatted preferences:\", safePreferences);\n    \n    // Prepare the OpenAI prompt with explicit values\n    const promptContent = `You are a task scheduling assistant. Optimize the user's tasks based on priorities, deadlines, and existing calendar events.\n            \nIMPORTANT SCHEDULING RULES:\n1. Tasks must NEVER overlap with each other or with existing calendar events\n2. Higher priority tasks should be scheduled earlier, especially those with imminent deadlines\n3. If a task is longer than ${safePreferences.splitTaskThreshold} hours, break it into multiple smaller sessions across different time slots or days\n4. Schedule ONLY ONE task per time slot - absolutely no overlapping tasks\n5. Strictly honor the user's working hours: Start at ${workStartFormatted} and end at ${workEndFormatted} each day\n6. Include ${safePreferences.breakBetweenTasks}-minute breaks between consecutive tasks\n7. Schedule a maximum of ${safePreferences.maxTasksPerDay} tasks per day, utilizing the full working day\n8. Put highest priority on meeting the deadline for each task\n9. Schedule tasks efficiently to maximize the use of available time within working hours\n\nFormat your response as a JSON array of scheduled tasks, with each task having:\n- id: The original task ID\n- title: Task title \n- start: Start time (ISO format)\n- end: End time (ISO format)\n- category: Task category (use the original task's category)\n- notes: Optional scheduling notes (e.g., \"Part 1 of 3\" for split tasks)\n\nEach task must have a specific time slot with no overlaps.`;\n\n    // Log full debug data\n    console.log(\"Full task data being sent to OpenAI:\", JSON.stringify(taskData, null, 2));\n    \n    // Make the API request\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: promptContent\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              tasks: taskData,\n              events: calendarEvents,\n              preferences: safePreferences\n            })\n          }\n        ],\n        temperature: 0.2, // Lower temperature for more deterministic results\n        max_tokens: 1500\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    console.log(\"OpenAI response received\");\n    \n    // Parse and validate the OpenAI response\n    let parsedSchedule;\n    try {\n      const responseContent = response.data.choices[0].message.content;\n      console.log(\"Raw OpenAI response:\", responseContent);\n      \n      parsedSchedule = JSON.parse(responseContent);\n      console.log(\"Parsed schedule result:\", parsedSchedule);\n      \n      // Validate each task has required fields\n      const validSchedule = Array.isArray(parsedSchedule) && parsedSchedule.every(task => \n        task.id && task.title && task.start && task.end\n      );\n      \n      if (!validSchedule) {\n        throw new Error(\"Invalid schedule format returned\");\n      }\n    } catch (error) {\n      console.error(\"Failed to parse OpenAI response:\", error);\n      return fallbackScheduling(tasks, events, safePreferences);\n    }\n    \n    // Convert string dates to Date objects and ensure proper formatting\n    return parsedSchedule.map(task => {\n      const originalTask = tasks.find(t => t.id === task.id);\n      let categoryValue;\n      \n      // Handle category properly with robust fallbacks\n      if (originalTask && originalTask.category) {\n        categoryValue = originalTask.category;\n      } else if (task.category) {\n        // If task has category but we can't find original, create a category object\n        if (typeof task.category === 'string') {\n          // Find a matching category from the original tasks if possible\n          const matchingCategoryFromTasks = tasks.find(t => \n            t.category && (\n              (typeof t.category === 'object' && t.category.id === task.category) ||\n              (typeof t.category === 'string' && t.category === task.category)\n            )\n          )?.category;\n          \n          if (matchingCategoryFromTasks) {\n            categoryValue = matchingCategoryFromTasks;\n          } else {\n            // Create a basic category object\n            categoryValue = { \n              id: task.category, \n              name: task.category.charAt(0).toUpperCase() + task.category.slice(1),\n              color: '#4CAF50' // Default color\n            };\n          }\n        } else {\n          // Category is already an object\n          categoryValue = task.category;\n        }\n      } else {\n        // Default category as a last resort\n        categoryValue = { \n          id: 'work', \n          name: 'Work',\n          color: '#4CAF50'\n        };\n      }\n      \n      // Ensure valid start and end dates\n      let startTime, endTime;\n      try {\n        startTime = new Date(task.start);\n        if (isNaN(startTime.getTime())) {\n          throw new Error(\"Invalid start time\");\n        }\n      } catch (e) {\n        console.warn(`Invalid start time for task ${task.id}, using current time:`, e);\n        startTime = new Date();\n      }\n      \n      try {\n        endTime = new Date(task.end);\n        if (isNaN(endTime.getTime())) {\n          throw new Error(\"Invalid end time\");\n        }\n      } catch (e) {\n        console.warn(`Invalid end time for task ${task.id}, using start + 1 hour:`, e);\n        endTime = new Date(startTime.getTime() + 60 * 60 * 1000);\n      }\n      \n      return {\n        ...task,\n        start: startTime,\n        end: endTime,\n        category: categoryValue\n      };\n    });\n  } catch (error) {\n    console.error('Error optimizing task schedule with OpenAI:', error);\n    \n    // Try the backend API\n    try {\n      console.log(\"Trying backend API for task scheduling\");\n      const response = await axios.post(`${API_URL}/schedule-tasks`, { \n        tasks, \n        events, \n        preferences \n      });\n      \n      // Convert string dates to Date objects in the schedule\n      return response.data.schedule.map(task => ({\n        ...task,\n        start: new Date(task.start),\n        end: new Date(task.end)\n      }));\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      console.log(\"Using local fallback scheduling algorithm\");\n      \n      // Fallback to basic scheduling algorithm\n      return fallbackScheduling(tasks, events, preferences);\n    }\n  }\n};\n\n// Fallback scheduling function when APIs fail\nconst fallbackScheduling = (tasks, events, preferences) => {\n  console.log(\"Using fallback scheduling function\");\n  \n  // Ensure tasks is an array\n  if (!Array.isArray(tasks) || tasks.length === 0) {\n    console.warn(\"No tasks provided for fallback scheduling\");\n    return [];\n  }\n  \n  // Validate preferences\n  const safePreferences = {\n    workingHours: {\n      start: preferences?.workingHours?.start || '09:00',\n      end: preferences?.workingHours?.end || '17:00'\n    },\n    maxTasksPerDay: isNaN(parseInt(preferences?.maxTasksPerDay, 10)) \n      ? DEFAULT_VALUES.maxTasksPerDay \n      : parseInt(preferences?.maxTasksPerDay, 10),\n    breakBetweenTasks: isNaN(parseInt(preferences?.breakBetweenTasks, 10)) \n      ? DEFAULT_VALUES.breakBetweenTasks \n      : parseInt(preferences?.breakBetweenTasks, 10),\n    splitTaskThreshold: isNaN(parseFloat(preferences?.splitTaskThreshold)) \n      ? DEFAULT_VALUES.splitTaskThreshold \n      : parseFloat(preferences?.splitTaskThreshold)\n  };\n  \n  // Sort tasks by priority (high to low) and deadline\n  const sortedTasks = [...tasks].sort((a, b) => {\n    // First get priority values safely\n    const getPriorityValue = (task) => {\n      if (task.priority !== undefined) {\n        if (typeof task.priority === 'object' && task.priority !== null) {\n          const value = parseInt(task.priority.value, 10);\n          return isNaN(value) ? DEFAULT_VALUES.priorityValue : value;\n        } else if (typeof task.priority === 'number' || typeof task.priority === 'string') {\n          const value = parseInt(task.priority, 10);\n          return isNaN(value) ? DEFAULT_VALUES.priorityValue : value;\n        }\n      }\n      return DEFAULT_VALUES.priorityValue;\n    };\n    \n    const priorityA = getPriorityValue(a);\n    const priorityB = getPriorityValue(b);\n    \n    // First by priority (high to low)\n    if (priorityB !== priorityA) {\n      return priorityB - priorityA;\n    }\n    \n    // Then by deadline (earlier first) if we can parse them\n    try {\n      return new Date(a.deadline) - new Date(b.deadline);\n    } catch (e) {\n      return 0; // If we can't compare deadlines, consider them equal\n    }\n  });\n  \n  const scheduledTasks = [];\n  const today = new Date();\n  \n  // Parse working hours\n  const parseTimeString = (timeStr) => {\n    try {\n      const parts = timeStr.split(':');\n      return {\n        hours: parseInt(parts[0], 10) || 0,\n        minutes: parseInt(parts[1], 10) || 0\n      };\n    } catch (e) {\n      console.warn(\"Could not parse time string:\", timeStr);\n      return { hours: 0, minutes: 0 };\n    }\n  };\n  \n  const workStart = parseTimeString(safePreferences.workingHours.start);\n  const workEnd = parseTimeString(safePreferences.workingHours.end);\n  \n  // Calculate break time in milliseconds\n  const breakTimeMs = safePreferences.breakBetweenTasks * 60 * 1000;\n  \n  // Start scheduling from today\n  let currentDay = new Date(today);\n  let tasksForToday = 0;\n  \n  // Set current time to working hours start\n  currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n  \n  for (const task of sortedTasks) {\n    // Get task duration in milliseconds - with validation\n    let duration = DEFAULT_VALUES.estimatedHours;\n    if (task.duration !== undefined) {\n      const parsedDuration = parseFloat(task.duration);\n      duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n    } else if (task.estimatedHours !== undefined) {\n      const parsedDuration = parseFloat(task.estimatedHours);\n      duration = isNaN(parsedDuration) ? DEFAULT_VALUES.estimatedHours : parsedDuration;\n    }\n    \n    const taskDurationMs = duration * 60 * 60 * 1000;\n    const splitThresholdMs = safePreferences.splitTaskThreshold * 60 * 60 * 1000;\n    \n    // Get category with validation\n    let categoryValue;\n    if (task.category) {\n      if (typeof task.category === 'object' && task.category !== null) {\n        categoryValue = task.category;\n      } else if (typeof task.category === 'string') {\n        categoryValue = {\n          id: task.category,\n          name: task.category.charAt(0).toUpperCase() + task.category.slice(1),\n          color: '#4CAF50'\n        };\n      }\n    } else {\n      categoryValue = {\n        id: 'work',\n        name: 'Work',\n        color: '#4CAF50'\n      };\n    }\n    \n    // Check if task should be split\n    if (taskDurationMs > splitThresholdMs) {\n      // Calculate how many parts to split into\n      const parts = Math.ceil(taskDurationMs / splitThresholdMs);\n      const partDurationMs = taskDurationMs / parts;\n      \n      for (let i = 0; i < parts; i++) {\n        if (tasksForToday >= safePreferences.maxTasksPerDay) {\n          // Move to next day\n          currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n          currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n          tasksForToday = 0;\n        }\n        \n        // Set end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + partDurationMs);\n        \n        // Check if end time exceeds working hours\n        const workingDayEnd = new Date(currentDay);\n        workingDayEnd.setHours(workEnd.hours, workEnd.minutes, 0, 0);\n        \n        if (endTime > workingDayEnd) {\n          // Move to next day\n          currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n          currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n          tasksForToday = 0;\n          \n          // Recalculate start and end time\n          const startTime = new Date(currentDay);\n          const endTime = new Date(startTime.getTime() + partDurationMs);\n          \n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title || task.name} (Part ${i + 1} of ${parts})`,\n            start: startTime,\n            end: endTime,\n            category: categoryValue,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        } else {\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title || task.name} (Part ${i + 1} of ${parts})`,\n            start: startTime,\n            end: endTime,\n            category: categoryValue,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        }\n        \n        // Increase task count and move time forward (including break)\n        tasksForToday++;\n        currentDay = new Date(endTime.getTime() + breakTimeMs);\n      }\n    } else {\n      // Handle regular tasks\n      if (tasksForToday >= safePreferences.maxTasksPerDay) {\n        // Move to next day\n        currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n        currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n        tasksForToday = 0;\n      }\n      \n      // Set end time\n      const startTime = new Date(currentDay);\n      const endTime = new Date(startTime.getTime() + taskDurationMs);\n      \n      // Check if end time exceeds working hours\n      const workingDayEnd = new Date(currentDay);\n      workingDayEnd.setHours(workEnd.hours, workEnd.minutes, 0, 0);\n      \n      if (endTime > workingDayEnd) {\n        // Move to next day\n        currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n        currentDay.setHours(workStart.hours, workStart.minutes, 0, 0);\n        tasksForToday = 0;\n        \n        // Recalculate start and end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + taskDurationMs);\n        \n        scheduledTasks.push({\n          id: task.id,\n          title: task.title || task.name,\n          start: startTime,\n          end: endTime,\n          category: categoryValue\n        });\n      } else {\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title || task.name,\n          start: startTime,\n          end: endTime,\n          category: categoryValue\n        });\n      }\n      \n      // Increase task count and move time forward (including break)\n      tasksForToday++;\n      currentDay = new Date(endTime.getTime() + breakTimeMs);\n    }\n  }\n  \n  return scheduledTasks;\n};\n\n// Create a named export object\nconst openAIService = {\n  optimizeTaskSchedule\n};\n\nexport default openAIService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}