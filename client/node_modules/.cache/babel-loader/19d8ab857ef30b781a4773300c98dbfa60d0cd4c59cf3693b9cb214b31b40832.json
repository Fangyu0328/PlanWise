{"ast":null,"code":"import axios from 'axios';\nconst API_URL = 'http://localhost:4000/api';\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || 'your-api-key-here';\nconst API_ENDPOINT = 'https://api.openai.com/v1/chat/completions';\n\n/**\n * Parse natural language input to calendar events with OpenAI\n * @param {string} text - Natural language description of event\n * @returns {Promise<Object>} - Parsed event data\n */\nexport const parseEventText = async text => {\n  try {\n    // Use OpenAI to process the event text\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a calendar event assistant. Extract event information from user input and create a simplified title.\n            \n            Examples:\n            - Input: \"I will have dinner with John tomorrow night at 7pm\"\n              Output: Title should be \"Dinner with John\", date is tomorrow, time is 7pm\n            - Input: \"Cancel my meeting with marketing team\"\n              Output: Action should be cancel, event to cancel is \"meeting with marketing team\"\n            \n            Format your response as a JSON object with these fields:\n            - action: 'add' or 'cancel'\n            - title: Simplified event title (remove date/time info, focus on the core event)\n            - start: Event start time (ISO format)\n            - end: Event end time (ISO format)\n            - location: Optional location (if mentioned)\n            - notes: Optional notes (if any additional information is provided)`\n      }, {\n        role: \"user\",\n        content: text\n      }],\n      temperature: 0.3,\n      max_tokens: 250\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    // Parse the OpenAI response\n    const result = JSON.parse(response.data.choices[0].message.content);\n\n    // Convert string dates to Date objects\n    return {\n      ...result,\n      start: new Date(result.start),\n      end: new Date(result.end)\n    };\n  } catch (error) {\n    console.error('Error processing event with OpenAI:', error);\n    // Fallback to API or simple parsing if OpenAI call fails\n    try {\n      const response = await axios.post(`${API_URL}/parse-event`, {\n        text\n      });\n      const result = response.data;\n      return {\n        ...result,\n        start: new Date(result.start),\n        end: new Date(result.end)\n      };\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n\n      // If available, use the local fallback function defined in SmartEventEntry\n      if (typeof window.fallbackParsing === 'function') {\n        return window.fallbackParsing(text);\n      }\n\n      // Return a basic event object as last resort\n      const now = new Date();\n      const later = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour later\n\n      return {\n        action: 'add',\n        title: text,\n        start: now,\n        end: later,\n        location: '',\n        notes: 'Created with basic fallback parsing.'\n      };\n    }\n  }\n};\n\n/**\n * Generate optimized task schedule based on priorities, deadlines, and existing calendar events\n * @param {Array} tasks - List of tasks with priorities and deadlines\n * @param {Array} events - Existing calendar events\n * @param {Object} preferences - User preferences for scheduling\n * @returns {Promise<Array>} - Optimized schedule of tasks\n */\nexport const optimizeTaskSchedule = async (tasks, events, preferences) => {\n  try {\n    // Prepare task and event data for OpenAI\n    const tasksData = tasks.map(task => ({\n      id: task.id,\n      title: task.title,\n      priority: task.priority,\n      duration: parseFloat(task.duration),\n      // Ensure it's a number\n      deadline: task.deadline,\n      // In ISO format with specific time\n      category: task.category ? task.category.id || task.category : 'work'\n    }));\n    const eventsData = events.map(event => ({\n      title: event.title,\n      start: typeof event.start === 'string' ? event.start : event.start.toISOString(),\n      end: typeof event.end === 'string' ? event.end : event.end.toISOString()\n    }));\n\n    // Extract working hours as actual times\n    const workStart = preferences.workingHours.start;\n    const workEnd = preferences.workingHours.end;\n\n    // Create a sample working day to demonstrate the schedule\n    const today = new Date();\n    const workingDayStart = new Date(today);\n    workingDayStart.setHours(parseInt(workStart.split(':')[0], 10), parseInt(workStart.split(':')[1], 10), 0, 0);\n    const workingDayEnd = new Date(today);\n    workingDayEnd.setHours(parseInt(workEnd.split(':')[0], 10), parseInt(workEnd.split(':')[1], 10), 0, 0);\n\n    // Ensure preferences are properly formatted\n    const formattedPreferences = {\n      workingHours: {\n        start: workStart,\n        end: workEnd,\n        startFormatted: workStart,\n        endFormatted: workEnd\n      },\n      maxTasksPerDay: preferences.maxTasksPerDay || 5,\n      breakBetweenTasks: preferences.breakBetweenTasks || 15,\n      // minutes\n      splitTaskThreshold: preferences.splitTaskThreshold || 2 // hours\n    };\n    console.log(\"Formatted preferences:\", formattedPreferences);\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a task scheduling assistant. Optimize the user's tasks based on priorities, deadlines, and existing calendar events.\n            \n            IMPORTANT SCHEDULING RULES:\n            1. Tasks must NEVER overlap with each other or with existing calendar events\n            2. Higher priority tasks should be scheduled earlier, especially those with imminent deadlines\n            3. If a task is longer than ${formattedPreferences.splitTaskThreshold} hours, break it into multiple smaller sessions across different time slots or days\n            4. Schedule ONLY ONE task per time slot - absolutely no overlapping tasks\n            5. Strictly honor the user's working hours: Start at ${formattedPreferences.workingHours.startFormatted} and end at ${formattedPreferences.workingHours.endFormatted} each day\n            6. Include ${formattedPreferences.breakBetweenTasks}-minute breaks between consecutive tasks\n            7. Schedule a maximum of ${formattedPreferences.maxTasksPerDay} tasks per day, utilizing the full working day\n            8. Put highest priority on meeting the deadline for each task\n            9. Schedule tasks efficiently to maximize the use of available time within working hours\n            \n            Format your response as a JSON array of scheduled tasks, with each task having:\n            - id: The original task ID\n            - title: Task title \n            - start: Start time (ISO format)\n            - end: End time (ISO format)\n            - category: Task category (use the original task's category)\n            - notes: Optional scheduling notes (e.g., \"Part 1 of 3\" for split tasks)\n            \n            Each task must have a specific time slot with no overlaps.`\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          tasks: tasksData,\n          events: eventsData,\n          preferences: formattedPreferences\n        })\n      }],\n      temperature: 0.2,\n      // Lower temperature for more deterministic results\n      max_tokens: 1500\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n\n    // Parse and process the OpenAI response\n    const result = JSON.parse(response.data.choices[0].message.content);\n    console.log(\"Parsed schedule result:\", result);\n\n    // Convert string dates to Date objects and ensure proper formatting\n    return result.map(task => {\n      var _tasks$find;\n      return {\n        ...task,\n        start: new Date(task.start),\n        end: new Date(task.end),\n        category: ((_tasks$find = tasks.find(t => t.id === task.id)) === null || _tasks$find === void 0 ? void 0 : _tasks$find.category) || {\n          id: task.category,\n          name: task.category\n        }\n      };\n    });\n  } catch (error) {\n    console.error('Error optimizing task schedule with OpenAI:', error);\n\n    // Try the backend API\n    try {\n      const response = await axios.post(`${API_URL}/schedule-tasks`, {\n        tasks,\n        events,\n        preferences\n      });\n\n      // Convert string dates to Date objects in the schedule\n      return response.data.schedule.map(task => ({\n        ...task,\n        start: new Date(task.start),\n        end: new Date(task.end)\n      }));\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n\n      // Fallback to basic scheduling algorithm\n      return fallbackScheduling(tasks, events, preferences);\n    }\n  }\n};\n\n/**\n * Find best meeting times based on participants' availability\n * @param {Array} participantAvailability - Availability data from all participants\n * @param {Object} meetingParams - Meeting parameters (duration, preferred days, etc.)\n * @returns {Promise<Array>} - Best meeting time slots\n */\nexport const findBestMeetingSlots = async (participantAvailability, meetingParams) => {\n  try {\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a meeting scheduling assistant. Find the best meeting times based on all participants' availability.\n            \n            Important considerations:\n            1. Prioritize slots where all participants are available\n            2. If no slot has 100% availability, find slots with maximum participation\n            3. Respect preferred days specified in the meeting parameters\n            4. Ensure the slot duration accommodates the required meeting length\n            5. Stay within the specified time range\n            \n            Format your response as a JSON array of available slots, each containing:\n            - day: Day of the week (e.g., 'monday')\n            - date: Formatted date (e.g., 'May 1')\n            - time: Time range (e.g., '10:00 AM - 11:00 AM')\n            - availability: 'all' or 'partial'\n            - availableCount: Number of available participants (if partial)\n            - totalCount: Total number of participants\n            \n            Sort the slots by best fit (all available first, then by number of available participants).`\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          participantAvailability: participantAvailability,\n          meetingParams: meetingParams\n        })\n      }],\n      temperature: 0.3,\n      max_tokens: 500\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    return JSON.parse(response.data.choices[0].message.content);\n  } catch (error) {\n    console.error('Error finding best meeting slots with OpenAI:', error);\n\n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/find-meeting-slots`, {\n        participantAvailability,\n        meetingParams\n      });\n      return response.data.slots;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackMeetingSlots(participantAvailability, meetingParams);\n    }\n  }\n};\n\n/**\n * Generate personalized habit recommendations based on mood and activity history\n * @param {Array} moodEntries - History of mood entries\n * @param {Array} activityEntries - History of activities\n * @returns {Promise<Array>} - Personalized recommendations\n */\nexport const generateRecommendations = async (moodEntries, activityEntries) => {\n  try {\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a personalized habit recommendation assistant. Analyze the user's mood patterns and activities to suggest an ideal daily schedule.\n            \n            Consider:\n            1. Time-specific mood patterns (morning, afternoon, evening)\n            2. Activities that correlate with positive moods\n            3. Balance across different activity categories\n            4. Sustainable habit formation principles\n            \n            Format your response as a JSON array of recommendation blocks, each with:\n            - id: Unique identifier for the recommendation\n            - title: Section title (e.g., 'Morning Routine', 'Productivity Boost')\n            - activities: Array of suggested activities with:\n              - time: Suggested time (e.g., '07:00 AM')\n              - description: Activity description\n              - category: Category ID (e.g., 'selfCare', 'work', 'exercise')\n              \n            The recommendations should be detailed yet realistic for daily implementation.`\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          moodEntries: moodEntries,\n          activityEntries: activityEntries\n        })\n      }],\n      temperature: 0.5,\n      max_tokens: 1000\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    return JSON.parse(response.data.choices[0].message.content);\n  } catch (error) {\n    console.error('Error generating recommendations with OpenAI:', error);\n\n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/generate-recommendations`, {\n        moodEntries,\n        activityEntries\n      });\n      return response.data.recommendations;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackRecommendations(moodEntries, activityEntries);\n    }\n  }\n};\n\n/**\n * Analyze evening reflection and provide feedback\n * @param {string} reflectionText - User's evening reflection\n * @param {Array} moodEntries - Recent mood entries\n * @param {Array} activityEntries - Recent activity entries\n * @returns {Promise<string>} - Personalized feedback\n */\nexport const analyzeReflection = async (reflectionText, moodEntries, activityEntries) => {\n  try {\n    const response = await axios.post(API_ENDPOINT, {\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: `You are a reflection analysis assistant. Provide insightful feedback on the user's evening reflection, considering their mood and activity patterns.\n            \n            Your feedback should:\n            1. Acknowledge positive behaviors and attitudes\n            2. Identify potential improvement areas tactfully\n            3. Offer specific suggestions aligned with their goals\n            4. Recommend potential habit adjustments based on patterns\n            5. Maintain a warm, encouraging tone\n            \n            Format your response as a thoughtful paragraph of feedback, keeping it concise yet meaningful.`\n      }, {\n        role: \"user\",\n        content: JSON.stringify({\n          reflection: reflectionText,\n          recentMoods: moodEntries.slice(0, 5),\n          recentActivities: activityEntries.slice(0, 10)\n        })\n      }],\n      temperature: 0.7,\n      max_tokens: 500\n    }, {\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    return response.data.choices[0].message.content;\n  } catch (error) {\n    console.error('Error analyzing reflection with OpenAI:', error);\n\n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/analyze-reflection`, {\n        reflectionText,\n        moodEntries,\n        activityEntries\n      });\n      return response.data.feedback;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackReflectionAnalysis(reflectionText);\n    }\n  }\n};\n\n// Fallback scheduling function when APIs fail\nconst fallbackScheduling = (tasks, events, preferences) => {\n  // Sort tasks by priority (high to low) and deadline\n  const sortedTasks = [...tasks].sort((a, b) => {\n    // First by priority (high to low)\n    if (b.priority.value !== a.priority.value) {\n      return b.priority.value - a.priority.value;\n    }\n    // Then by deadline (earlier first)\n    return new Date(a.deadline) - new Date(b.deadline);\n  });\n  const scheduledTasks = [];\n  const today = new Date();\n\n  // Parse working hours\n  const workStart = preferences.workingHours.start.split(':');\n  const workEnd = preferences.workingHours.end.split(':');\n  const workStartHour = parseInt(workStart[0], 10);\n  const workStartMinute = parseInt(workStart[1], 10);\n  const workEndHour = parseInt(workEnd[0], 10);\n  const workEndMinute = parseInt(workEnd[1], 10);\n\n  // Calculate break time in milliseconds\n  const breakTimeMs = preferences.breakBetweenTasks * 60 * 1000;\n\n  // Calculate max tasks per day setting\n  const maxTasksPerDay = preferences.maxTasksPerDay || 5;\n\n  // Start scheduling from today\n  let currentDay = new Date(today);\n  let tasksForToday = 0;\n\n  // Set current time to working hours start\n  currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n  for (const task of sortedTasks) {\n    // Get task duration in milliseconds\n    const taskDurationMs = parseFloat(task.duration) * 60 * 60 * 1000;\n    const splitThresholdMs = preferences.splitTaskThreshold * 60 * 60 * 1000;\n\n    // Check if task should be split\n    if (taskDurationMs > splitThresholdMs) {\n      // Calculate how many parts to split into\n      const parts = Math.ceil(taskDurationMs / splitThresholdMs);\n      const partDurationMs = taskDurationMs / parts;\n      for (let i = 0; i < parts; i++) {\n        if (tasksForToday >= maxTasksPerDay) {\n          // Move to next day\n          currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n          currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n          tasksForToday = 0;\n        }\n\n        // Set end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + partDurationMs);\n\n        // Check if end time exceeds working hours\n        const workingDayEnd = new Date(currentDay);\n        workingDayEnd.setHours(workEndHour, workEndMinute, 0, 0);\n        if (endTime > workingDayEnd) {\n          // Move to next day\n          currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n          currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n          tasksForToday = 0;\n\n          // Recalculate start and end time\n          const startTime = new Date(currentDay);\n          const endTime = new Date(startTime.getTime() + partDurationMs);\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title} (Part ${i + 1} of ${parts})`,\n            start: startTime,\n            end: endTime,\n            category: task.category,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        } else {\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title} (Part ${i + 1} of ${parts})`,\n            start: startTime,\n            end: endTime,\n            category: task.category,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        }\n\n        // Increase task count and move time forward (including break)\n        tasksForToday++;\n        currentDay = new Date(endTime.getTime() + breakTimeMs);\n      }\n    } else {\n      // Handle regular tasks\n      if (tasksForToday >= maxTasksPerDay) {\n        // Move to next day\n        currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n        currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n        tasksForToday = 0;\n      }\n\n      // Set end time\n      const startTime = new Date(currentDay);\n      const endTime = new Date(startTime.getTime() + taskDurationMs);\n\n      // Check if end time exceeds working hours\n      const workingDayEnd = new Date(currentDay);\n      workingDayEnd.setHours(workEndHour, workEndMinute, 0, 0);\n      if (endTime > workingDayEnd) {\n        // Move to next day\n        currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n        currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n        tasksForToday = 0;\n\n        // Recalculate start and end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + taskDurationMs);\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title,\n          start: startTime,\n          end: endTime,\n          category: task.category\n        });\n      } else {\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title,\n          start: startTime,\n          end: endTime,\n          category: task.category\n        });\n      }\n\n      // Increase task count and move time forward (including break)\n      tasksForToday++;\n      currentDay = new Date(endTime.getTime() + breakTimeMs);\n    }\n  }\n  return scheduledTasks;\n};\n\n// Fallback functions for meeting slots, recommendations, etc.\nconst fallbackMeetingSlots = (participantAvailability, meetingParams) => {\n  // Generate three dummy time slots\n  const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];\n\n  // Get preferred days or default to all weekdays\n  const preferredDays = meetingParams.preferredDays && meetingParams.preferredDays.length > 0 ? meetingParams.preferredDays : days;\n\n  // Create dummy slots\n  return [{\n    day: preferredDays[0] || 'monday',\n    date: 'May 1',\n    time: '10:00 AM - 11:00 AM',\n    availability: 'all'\n  }, {\n    day: preferredDays[preferredDays.length > 1 ? 1 : 0] || 'wednesday',\n    date: 'May 3',\n    time: '2:00 PM - 3:00 PM',\n    availability: 'all'\n  }, {\n    day: preferredDays[0] || 'monday',\n    date: 'May 8',\n    time: '11:00 AM - 12:00 PM',\n    availability: 'partial',\n    availableCount: 2,\n    totalCount: 3\n  }];\n};\nconst fallbackRecommendations = (moodEntries, activityEntries) => {\n  // Simple recommendations\n  return [{\n    id: 'morning',\n    title: 'Morning Routine',\n    activities: [{\n      time: '07:00 AM',\n      description: 'Wake up & hydrate',\n      category: 'selfCare'\n    }, {\n      time: '07:15 AM',\n      description: 'Quick stretch or meditation',\n      category: 'selfCare'\n    }, {\n      time: '07:45 AM',\n      description: 'Healthy breakfast',\n      category: 'selfCare'\n    }, {\n      time: '08:15 AM',\n      description: 'Plan your day',\n      category: 'work'\n    }]\n  }, {\n    id: 'balance',\n    title: 'Balance Your Day',\n    activities: [{\n      time: '11:30 AM',\n      description: 'Take a short break',\n      category: 'selfCare'\n    }, {\n      time: '05:00 PM',\n      description: 'Transition from work to personal time',\n      category: 'selfCare'\n    }, {\n      time: '07:00 PM',\n      description: 'Dinner & relaxation',\n      category: 'leisure'\n    }, {\n      time: '10:00 PM',\n      description: 'Wind down routine',\n      category: 'sleep'\n    }]\n  }];\n};\nconst fallbackReflectionAnalysis = reflectionText => {\n  return \"Thank you for sharing your reflection. It's great that you're taking time to review your day. Consider how your activities might be affecting your mood, and remember that small adjustments can lead to significant improvements in your well-being. Keep up the good work with your self-reflection practice!\";\n};\n\n// Create a named export object\nconst openAIService = {\n  parseEventText,\n  optimizeTaskSchedule,\n  findBestMeetingSlots,\n  generateRecommendations,\n  analyzeReflection\n};\nexport default openAIService;","map":{"version":3,"names":["axios","API_URL","OPENAI_API_KEY","process","env","REACT_APP_OPENAI_API_KEY","API_ENDPOINT","parseEventText","text","response","post","model","messages","role","content","temperature","max_tokens","headers","result","JSON","parse","data","choices","message","start","Date","end","error","console","backendError","window","fallbackParsing","now","later","getTime","action","title","location","notes","optimizeTaskSchedule","tasks","events","preferences","tasksData","map","task","id","priority","duration","parseFloat","deadline","category","eventsData","event","toISOString","workStart","workingHours","workEnd","today","workingDayStart","setHours","parseInt","split","workingDayEnd","formattedPreferences","startFormatted","endFormatted","maxTasksPerDay","breakBetweenTasks","splitTaskThreshold","log","stringify","_tasks$find","find","t","name","schedule","fallbackScheduling","findBestMeetingSlots","participantAvailability","meetingParams","slots","fallbackMeetingSlots","generateRecommendations","moodEntries","activityEntries","recommendations","fallbackRecommendations","analyzeReflection","reflectionText","reflection","recentMoods","slice","recentActivities","feedback","fallbackReflectionAnalysis","sortedTasks","sort","a","b","value","scheduledTasks","workStartHour","workStartMinute","workEndHour","workEndMinute","breakTimeMs","currentDay","tasksForToday","taskDurationMs","splitThresholdMs","parts","Math","ceil","partDurationMs","i","startTime","endTime","push","days","preferredDays","length","day","date","time","availability","availableCount","totalCount","activities","description","openAIService"],"sources":["/Users/wenxinmiao/Desktop/PlanWise/client/src/Services/openAIservice.js"],"sourcesContent":["import axios from 'axios';\n\nconst API_URL = 'http://localhost:4000/api';\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || 'your-api-key-here';\nconst API_ENDPOINT = 'https://api.openai.com/v1/chat/completions';\n\n/**\n * Parse natural language input to calendar events with OpenAI\n * @param {string} text - Natural language description of event\n * @returns {Promise<Object>} - Parsed event data\n */\nexport const parseEventText = async (text) => {\n  try {\n    // Use OpenAI to process the event text\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a calendar event assistant. Extract event information from user input and create a simplified title.\n            \n            Examples:\n            - Input: \"I will have dinner with John tomorrow night at 7pm\"\n              Output: Title should be \"Dinner with John\", date is tomorrow, time is 7pm\n            - Input: \"Cancel my meeting with marketing team\"\n              Output: Action should be cancel, event to cancel is \"meeting with marketing team\"\n            \n            Format your response as a JSON object with these fields:\n            - action: 'add' or 'cancel'\n            - title: Simplified event title (remove date/time info, focus on the core event)\n            - start: Event start time (ISO format)\n            - end: Event end time (ISO format)\n            - location: Optional location (if mentioned)\n            - notes: Optional notes (if any additional information is provided)`\n          },\n          {\n            role: \"user\",\n            content: text\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 250\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    // Parse the OpenAI response\n    const result = JSON.parse(response.data.choices[0].message.content);\n    \n    // Convert string dates to Date objects\n    return {\n      ...result,\n      start: new Date(result.start),\n      end: new Date(result.end)\n    };\n  } catch (error) {\n    console.error('Error processing event with OpenAI:', error);\n    // Fallback to API or simple parsing if OpenAI call fails\n    try {\n      const response = await axios.post(`${API_URL}/parse-event`, { text });\n      const result = response.data;\n      \n      return {\n        ...result,\n        start: new Date(result.start),\n        end: new Date(result.end)\n      };\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      \n      // If available, use the local fallback function defined in SmartEventEntry\n      if (typeof window.fallbackParsing === 'function') {\n        return window.fallbackParsing(text);\n      }\n      \n      // Return a basic event object as last resort\n      const now = new Date();\n      const later = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour later\n      \n      return {\n        action: 'add',\n        title: text,\n        start: now,\n        end: later,\n        location: '',\n        notes: 'Created with basic fallback parsing.'\n      };\n    }\n  }\n};\n\n/**\n * Generate optimized task schedule based on priorities, deadlines, and existing calendar events\n * @param {Array} tasks - List of tasks with priorities and deadlines\n * @param {Array} events - Existing calendar events\n * @param {Object} preferences - User preferences for scheduling\n * @returns {Promise<Array>} - Optimized schedule of tasks\n */\nexport const optimizeTaskSchedule = async (tasks, events, preferences) => {\n  try {\n    // Prepare task and event data for OpenAI\n    const tasksData = tasks.map(task => ({\n      id: task.id,\n      title: task.title,\n      priority: task.priority,\n      duration: parseFloat(task.duration), // Ensure it's a number\n      deadline: task.deadline, // In ISO format with specific time\n      category: task.category ? task.category.id || task.category : 'work'\n    }));\n    \n    const eventsData = events.map(event => ({\n      title: event.title,\n      start: typeof event.start === 'string' ? event.start : event.start.toISOString(),\n      end: typeof event.end === 'string' ? event.end : event.end.toISOString()\n    }));\n    \n    // Extract working hours as actual times\n    const workStart = preferences.workingHours.start;\n    const workEnd = preferences.workingHours.end;\n    \n    // Create a sample working day to demonstrate the schedule\n    const today = new Date();\n    const workingDayStart = new Date(today);\n    workingDayStart.setHours(\n      parseInt(workStart.split(':')[0], 10),\n      parseInt(workStart.split(':')[1], 10),\n      0,\n      0\n    );\n    \n    const workingDayEnd = new Date(today);\n    workingDayEnd.setHours(\n      parseInt(workEnd.split(':')[0], 10),\n      parseInt(workEnd.split(':')[1], 10),\n      0,\n      0\n    );\n    \n    // Ensure preferences are properly formatted\n    const formattedPreferences = {\n      workingHours: {\n        start: workStart,\n        end: workEnd,\n        startFormatted: workStart,\n        endFormatted: workEnd\n      },\n      maxTasksPerDay: preferences.maxTasksPerDay || 5,\n      breakBetweenTasks: preferences.breakBetweenTasks || 15, // minutes\n      splitTaskThreshold: preferences.splitTaskThreshold || 2 // hours\n    };\n    \n    console.log(\"Formatted preferences:\", formattedPreferences);\n    \n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a task scheduling assistant. Optimize the user's tasks based on priorities, deadlines, and existing calendar events.\n            \n            IMPORTANT SCHEDULING RULES:\n            1. Tasks must NEVER overlap with each other or with existing calendar events\n            2. Higher priority tasks should be scheduled earlier, especially those with imminent deadlines\n            3. If a task is longer than ${formattedPreferences.splitTaskThreshold} hours, break it into multiple smaller sessions across different time slots or days\n            4. Schedule ONLY ONE task per time slot - absolutely no overlapping tasks\n            5. Strictly honor the user's working hours: Start at ${formattedPreferences.workingHours.startFormatted} and end at ${formattedPreferences.workingHours.endFormatted} each day\n            6. Include ${formattedPreferences.breakBetweenTasks}-minute breaks between consecutive tasks\n            7. Schedule a maximum of ${formattedPreferences.maxTasksPerDay} tasks per day, utilizing the full working day\n            8. Put highest priority on meeting the deadline for each task\n            9. Schedule tasks efficiently to maximize the use of available time within working hours\n            \n            Format your response as a JSON array of scheduled tasks, with each task having:\n            - id: The original task ID\n            - title: Task title \n            - start: Start time (ISO format)\n            - end: End time (ISO format)\n            - category: Task category (use the original task's category)\n            - notes: Optional scheduling notes (e.g., \"Part 1 of 3\" for split tasks)\n            \n            Each task must have a specific time slot with no overlaps.`\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              tasks: tasksData,\n              events: eventsData,\n              preferences: formattedPreferences\n            })\n          }\n        ],\n        temperature: 0.2, // Lower temperature for more deterministic results\n        max_tokens: 1500\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    // Parse and process the OpenAI response\n    const result = JSON.parse(response.data.choices[0].message.content);\n    console.log(\"Parsed schedule result:\", result);\n    \n    // Convert string dates to Date objects and ensure proper formatting\n    return result.map(task => ({\n      ...task,\n      start: new Date(task.start),\n      end: new Date(task.end),\n      category: tasks.find(t => t.id === task.id)?.category || { id: task.category, name: task.category }\n    }));\n  } catch (error) {\n    console.error('Error optimizing task schedule with OpenAI:', error);\n    \n    // Try the backend API\n    try {\n      const response = await axios.post(`${API_URL}/schedule-tasks`, { \n        tasks, \n        events, \n        preferences \n      });\n      \n      // Convert string dates to Date objects in the schedule\n      return response.data.schedule.map(task => ({\n        ...task,\n        start: new Date(task.start),\n        end: new Date(task.end)\n      }));\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      \n      // Fallback to basic scheduling algorithm\n      return fallbackScheduling(tasks, events, preferences);\n    }\n  }\n};\n\n/**\n * Find best meeting times based on participants' availability\n * @param {Array} participantAvailability - Availability data from all participants\n * @param {Object} meetingParams - Meeting parameters (duration, preferred days, etc.)\n * @returns {Promise<Array>} - Best meeting time slots\n */\nexport const findBestMeetingSlots = async (participantAvailability, meetingParams) => {\n  try {\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a meeting scheduling assistant. Find the best meeting times based on all participants' availability.\n            \n            Important considerations:\n            1. Prioritize slots where all participants are available\n            2. If no slot has 100% availability, find slots with maximum participation\n            3. Respect preferred days specified in the meeting parameters\n            4. Ensure the slot duration accommodates the required meeting length\n            5. Stay within the specified time range\n            \n            Format your response as a JSON array of available slots, each containing:\n            - day: Day of the week (e.g., 'monday')\n            - date: Formatted date (e.g., 'May 1')\n            - time: Time range (e.g., '10:00 AM - 11:00 AM')\n            - availability: 'all' or 'partial'\n            - availableCount: Number of available participants (if partial)\n            - totalCount: Total number of participants\n            \n            Sort the slots by best fit (all available first, then by number of available participants).`\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              participantAvailability: participantAvailability,\n              meetingParams: meetingParams\n            })\n          }\n        ],\n        temperature: 0.3,\n        max_tokens: 500\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    return JSON.parse(response.data.choices[0].message.content);\n  } catch (error) {\n    console.error('Error finding best meeting slots with OpenAI:', error);\n    \n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/find-meeting-slots`, {\n        participantAvailability,\n        meetingParams\n      });\n      \n      return response.data.slots;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackMeetingSlots(participantAvailability, meetingParams);\n    }\n  }\n};\n\n/**\n * Generate personalized habit recommendations based on mood and activity history\n * @param {Array} moodEntries - History of mood entries\n * @param {Array} activityEntries - History of activities\n * @returns {Promise<Array>} - Personalized recommendations\n */\nexport const generateRecommendations = async (moodEntries, activityEntries) => {\n  try {\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a personalized habit recommendation assistant. Analyze the user's mood patterns and activities to suggest an ideal daily schedule.\n            \n            Consider:\n            1. Time-specific mood patterns (morning, afternoon, evening)\n            2. Activities that correlate with positive moods\n            3. Balance across different activity categories\n            4. Sustainable habit formation principles\n            \n            Format your response as a JSON array of recommendation blocks, each with:\n            - id: Unique identifier for the recommendation\n            - title: Section title (e.g., 'Morning Routine', 'Productivity Boost')\n            - activities: Array of suggested activities with:\n              - time: Suggested time (e.g., '07:00 AM')\n              - description: Activity description\n              - category: Category ID (e.g., 'selfCare', 'work', 'exercise')\n              \n            The recommendations should be detailed yet realistic for daily implementation.`\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              moodEntries: moodEntries,\n              activityEntries: activityEntries\n            })\n          }\n        ],\n        temperature: 0.5,\n        max_tokens: 1000\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    return JSON.parse(response.data.choices[0].message.content);\n  } catch (error) {\n    console.error('Error generating recommendations with OpenAI:', error);\n    \n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/generate-recommendations`, {\n        moodEntries,\n        activityEntries\n      });\n      \n      return response.data.recommendations;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackRecommendations(moodEntries, activityEntries);\n    }\n  }\n};\n\n/**\n * Analyze evening reflection and provide feedback\n * @param {string} reflectionText - User's evening reflection\n * @param {Array} moodEntries - Recent mood entries\n * @param {Array} activityEntries - Recent activity entries\n * @returns {Promise<string>} - Personalized feedback\n */\nexport const analyzeReflection = async (reflectionText, moodEntries, activityEntries) => {\n  try {\n    const response = await axios.post(\n      API_ENDPOINT,\n      {\n        model: \"gpt-4\",\n        messages: [\n          {\n            role: \"system\",\n            content: `You are a reflection analysis assistant. Provide insightful feedback on the user's evening reflection, considering their mood and activity patterns.\n            \n            Your feedback should:\n            1. Acknowledge positive behaviors and attitudes\n            2. Identify potential improvement areas tactfully\n            3. Offer specific suggestions aligned with their goals\n            4. Recommend potential habit adjustments based on patterns\n            5. Maintain a warm, encouraging tone\n            \n            Format your response as a thoughtful paragraph of feedback, keeping it concise yet meaningful.`\n          },\n          {\n            role: \"user\",\n            content: JSON.stringify({\n              reflection: reflectionText,\n              recentMoods: moodEntries.slice(0, 5),\n              recentActivities: activityEntries.slice(0, 10)\n            })\n          }\n        ],\n        temperature: 0.7,\n        max_tokens: 500\n      },\n      {\n        headers: {\n          'Authorization': `Bearer ${OPENAI_API_KEY}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    return response.data.choices[0].message.content;\n  } catch (error) {\n    console.error('Error analyzing reflection with OpenAI:', error);\n    \n    // Try backend API\n    try {\n      const response = await axios.post(`${API_URL}/analyze-reflection`, {\n        reflectionText,\n        moodEntries,\n        activityEntries\n      });\n      \n      return response.data.feedback;\n    } catch (backendError) {\n      console.error('Backend API also failed:', backendError);\n      return fallbackReflectionAnalysis(reflectionText);\n    }\n  }\n};\n\n// Fallback scheduling function when APIs fail\nconst fallbackScheduling = (tasks, events, preferences) => {\n  // Sort tasks by priority (high to low) and deadline\n  const sortedTasks = [...tasks].sort((a, b) => {\n    // First by priority (high to low)\n    if (b.priority.value !== a.priority.value) {\n      return b.priority.value - a.priority.value;\n    }\n    // Then by deadline (earlier first)\n    return new Date(a.deadline) - new Date(b.deadline);\n  });\n  \n  const scheduledTasks = [];\n  const today = new Date();\n  \n  // Parse working hours\n  const workStart = preferences.workingHours.start.split(':');\n  const workEnd = preferences.workingHours.end.split(':');\n  const workStartHour = parseInt(workStart[0], 10);\n  const workStartMinute = parseInt(workStart[1], 10);\n  const workEndHour = parseInt(workEnd[0], 10);\n  const workEndMinute = parseInt(workEnd[1], 10);\n  \n  // Calculate break time in milliseconds\n  const breakTimeMs = preferences.breakBetweenTasks * 60 * 1000;\n  \n  // Calculate max tasks per day setting\n  const maxTasksPerDay = preferences.maxTasksPerDay || 5;\n  \n  // Start scheduling from today\n  let currentDay = new Date(today);\n  let tasksForToday = 0;\n  \n  // Set current time to working hours start\n  currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n  \n  for (const task of sortedTasks) {\n    // Get task duration in milliseconds\n    const taskDurationMs = parseFloat(task.duration) * 60 * 60 * 1000;\n    const splitThresholdMs = preferences.splitTaskThreshold * 60 * 60 * 1000;\n    \n    // Check if task should be split\n    if (taskDurationMs > splitThresholdMs) {\n      // Calculate how many parts to split into\n      const parts = Math.ceil(taskDurationMs / splitThresholdMs);\n      const partDurationMs = taskDurationMs / parts;\n      \n      for (let i = 0; i < parts; i++) {\n        if (tasksForToday >= maxTasksPerDay) {\n          // Move to next day\n          currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n          currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n          tasksForToday = 0;\n        }\n        \n        // Set end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + partDurationMs);\n        \n        // Check if end time exceeds working hours\n        const workingDayEnd = new Date(currentDay);\n        workingDayEnd.setHours(workEndHour, workEndMinute, 0, 0);\n        \n        if (endTime > workingDayEnd) {\n          // Move to next day\n          currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n          currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n          tasksForToday = 0;\n          \n          // Recalculate start and end time\n          const startTime = new Date(currentDay);\n          const endTime = new Date(startTime.getTime() + partDurationMs);\n          \n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title} (Part ${i + 1} of ${parts})`,\n            start: startTime,\n            end: endTime,\n            category: task.category,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        } else {\n          scheduledTasks.push({\n            id: task.id,\n            title: `${task.title} (Part ${i + 1} of ${parts})`,\n            start: startTime,\n            end: endTime,\n            category: task.category,\n            notes: `Part ${i + 1} of ${parts}`\n          });\n        }\n        \n        // Increase task count and move time forward (including break)\n        tasksForToday++;\n        currentDay = new Date(endTime.getTime() + breakTimeMs);\n      }\n    } else {\n      // Handle regular tasks\n      if (tasksForToday >= maxTasksPerDay) {\n        // Move to next day\n        currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n        currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n        tasksForToday = 0;\n      }\n      \n      // Set end time\n      const startTime = new Date(currentDay);\n      const endTime = new Date(startTime.getTime() + taskDurationMs);\n      \n      // Check if end time exceeds working hours\n      const workingDayEnd = new Date(currentDay);\n      workingDayEnd.setHours(workEndHour, workEndMinute, 0, 0);\n      \n      if (endTime > workingDayEnd) {\n        // Move to next day\n        currentDay = new Date(currentDay.getTime() + 24 * 60 * 60 * 1000);\n        currentDay.setHours(workStartHour, workStartMinute, 0, 0);\n        tasksForToday = 0;\n        \n        // Recalculate start and end time\n        const startTime = new Date(currentDay);\n        const endTime = new Date(startTime.getTime() + taskDurationMs);\n        \n        scheduledTasks.push({\n          id: task.id,\n          title: task.title,\n          start: startTime,\n          end: endTime,\n          category: task.category\n        });\n      } else {\n        scheduledTasks.push({\n          id: task.id,\n          title: task.title,\n          start: startTime,\n          end: endTime,\n          category: task.category\n        });\n      }\n      \n      // Increase task count and move time forward (including break)\n      tasksForToday++;\n      currentDay = new Date(endTime.getTime() + breakTimeMs);\n    }\n  }\n  \n  return scheduledTasks;\n};\n\n// Fallback functions for meeting slots, recommendations, etc.\nconst fallbackMeetingSlots = (participantAvailability, meetingParams) => {\n  // Generate three dummy time slots\n  const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];\n  \n  // Get preferred days or default to all weekdays\n  const preferredDays = meetingParams.preferredDays && meetingParams.preferredDays.length > 0 \n    ? meetingParams.preferredDays \n    : days;\n  \n  // Create dummy slots\n  return [\n    {\n      day: preferredDays[0] || 'monday',\n      date: 'May 1',\n      time: '10:00 AM - 11:00 AM',\n      availability: 'all'\n    },\n    {\n      day: preferredDays[preferredDays.length > 1 ? 1 : 0] || 'wednesday',\n      date: 'May 3',\n      time: '2:00 PM - 3:00 PM',\n      availability: 'all'\n    },\n    {\n      day: preferredDays[0] || 'monday',\n      date: 'May 8',\n      time: '11:00 AM - 12:00 PM',\n      availability: 'partial',\n      availableCount: 2,\n      totalCount: 3\n    }\n  ];\n};\n\nconst fallbackRecommendations = (moodEntries, activityEntries) => {\n  // Simple recommendations\n  return [\n    {\n      id: 'morning',\n      title: 'Morning Routine',\n      activities: [\n        { time: '07:00 AM', description: 'Wake up & hydrate', category: 'selfCare' },\n        { time: '07:15 AM', description: 'Quick stretch or meditation', category: 'selfCare' },\n        { time: '07:45 AM', description: 'Healthy breakfast', category: 'selfCare' },\n        { time: '08:15 AM', description: 'Plan your day', category: 'work' },\n      ]\n    },\n    {\n      id: 'balance',\n      title: 'Balance Your Day',\n      activities: [\n        { time: '11:30 AM', description: 'Take a short break', category: 'selfCare' },\n        { time: '05:00 PM', description: 'Transition from work to personal time', category: 'selfCare' },\n        { time: '07:00 PM', description: 'Dinner & relaxation', category: 'leisure' },\n        { time: '10:00 PM', description: 'Wind down routine', category: 'sleep' },\n      ]\n    }\n  ];\n};\n\nconst fallbackReflectionAnalysis = (reflectionText) => {\n  return \"Thank you for sharing your reflection. It's great that you're taking time to review your day. Consider how your activities might be affecting your mood, and remember that small adjustments can lead to significant improvements in your well-being. Keep up the good work with your self-reflection practice!\";\n};\n\n// Create a named export object\nconst openAIService = {\n  parseEventText,\n  optimizeTaskSchedule,\n  findBestMeetingSlots,\n  generateRecommendations,\n  analyzeReflection\n};\n\nexport default openAIService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}